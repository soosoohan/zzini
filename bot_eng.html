<!DOCTYPE html>

<html lang="ko">
<head>
        <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4YZHC1G9FN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

gtag(â€˜configâ€™, â€˜G-4YZHC1G9FNâ€™);
</script>

<meta charset="UTF-8" />
  <title>WORPUZZ ZZINI</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f0f8f7;
      margin: 0;
      padding: 20px;
      color: #333;
      text-align: center;
    }
    h1 {
      font-size: 25px;
      margin-bottom: 10px;
      font-weight: bold;
      color: #064d4d;
    }
    p {
      font-size: 25px;
      margin-bottom: 10px;
      font-weight: bold;
      color: #064d4d;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .player-input {
      margin: 10px;
    }
    .player-input input {
      font-size: 18px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 150px;
      text-align: center;
      margin: 0 5px;
    }
    .guess-section {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .guess-section input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #aaa;
      border-radius: 4px;
      width: 200px;
    }
    .game-area {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .game-button {
      font-size: 18px;
      background-color: #c8f4ee;
      padding: 10px 22px;
      margin: 8px;
      color: #064d4d;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .game-button:hover {
      background-color: #1d9e95;
      color: white;
      transform: scale(1.05);
    }
    .cell {
      width: 41px;
      height: 41px;
      background-color: #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      cursor: pointer;
      user-select: none;
      border: 1px solid #999;
    }
    .revealed { background-color: #fff; }
    .word-owned-player1 { background-color: #b7d5f2; }
    .word-owned-player2 { background-color: #f6c28b; }
    #player1Score, #player2Score {
      width: 160px;
      min-height: 300px;
      padding: 10px;
      font-size: 18px;
      font-weight: bold;
      border: 2px solid #333;
    }
    #player1Score { background-color: #b7d5f2; }
    #player2Score { background-color: #f6c28b; }
    #currentTurn {
      font-size: 20px;
      margin: 10px;
      color: #056762;
      font-weight: bold;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(19, 45px);
      grid-gap: 3px;
      padding: 10px;
      border: 2px solid #333;
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
    .inline { 
      display: inline-block;
      margin: 0 10px;
    }
    #setupSection {
      margin: 20px 0;
    }
    .setup-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    .player-inputs {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .start-section {
      margin: 20px 0;
    }
  </style>
</head>

<body>

<h1 id="game-title" class="inline">WORPUZZ ZZINI</h1>
<p id="game-desc" class="inline">ë‹¨ì–´ ì°¾ê¸° ê²Œì„</p>

<div class="game-container">
  <!-- ê²Œì„ ì§„í–‰ ì„¹ì…˜ -->
  <div id="gameSection">
    <div id="currentTurn"></div>


<div class="guess-section">
  <input type="text" id="guessInput" placeholder="YOUR GUESS(UPPERCASE)" />
  <button id="guessBtn" class="game-button">SUBMIT</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>Invalid words:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

<div class="controls">
  <button id="retryBtn" class="game-button">Retry</button>
  <button onclick="location.href='index.html'" class="game-button">Home</button>
</div>


  </div>
</div>

<script>
const gridWidth = 19;
const gridHeight = 12;
const totalCells = gridWidth * gridHeight;
let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
let player1 = "í”Œë ˆì´ì–´1", player2 = "í”Œë ˆì´ì–´2", currentPlayerName = "", wrongGuesses = [];

const gameEl = document.getElementById('game');
const player1ScoreEl = document.getElementById('player1Score');
const player2ScoreEl = document.getElementById('player2Score');
const retryBtn = document.getElementById('retryBtn');
const backBtn = document.getElementById('backBtn');
const gameSection = document.getElementById('gameSection');
const currentTurnEl = document.getElementById('currentTurn');
const guessInput = document.getElementById('guessInput');
const guessBtn = document.getElementById('guessBtn');
const wrongListEl = document.getElementById('wrongList');
const wrongGuessesEl = document.getElementById('wrongGuesses');

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  
  if (!poolFile) {
    // ê¸°ë³¸ ë‹¨ì–´ë“¤ ì„¤ì •
    words = [
      'GRANDFATHER', 'GRANDMOTHER', 'GRANDPARENT', 'INTERESTING', 
      'SUPERMARKET', 'CONVERSATION', 'INFORMATION', 'DESCRIPTION',
      'UNDERSTANDING', 'INTERNATIONAL', 'ENTERTAINMENT', 'DEVELOPMENT',
      'HELLO', 'WORLD', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'SEARCH'
    ];
    console.log('ê¸°ë³¸ ë‹¨ì–´ë¡œ ì„¤ì •ë¨:', words.length + 'ê°œ');
    // ë°”ë¡œ ê²Œì„ ì‹œì‘
    startGame();
    return;
  }

  // ì›Œë“œí’€ íŒŒì¼ ë¡œë”© ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œ íŒŒì¼ì´ ì—†ìœ¼ë¯€ë¡œ)
  console.log('ì›Œë“œí’€ íŒŒì¼ ë¡œë”© ì‹œë„:', poolFile);
  
  // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” fetchë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ê¸°ë³¸ê°’ ì‚¬ìš©
  words = [
    'GRANDFATHER', 'GRANDMOTHER', 'GRANDPARENT', 'INTERESTING', 
    'SUPERMARKET', 'CONVERSATION', 'INFORMATION', 'DESCRIPTION',
    'UNDERSTANDING', 'INTERNATIONAL', 'ENTERTAINMENT', 'DEVELOPMENT',
    'HELLO', 'WORLD', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'SEARCH'
  ];
  
  document.getElementById('game-title').textContent = 'WORPUZZ ZZINI';
  document.getElementById('game-desc').innerHTML = 'ë‹¨ì–´ ì°¾ê¸° ê²Œì„';
  console.log('ì›Œë“œí’€ ë¡œë”© ì™„ë£Œ (ì‹œë®¬ë ˆì´ì…˜)');
  
  // í˜ì´ì§€ ë¡œë“œ í›„ ë°”ë¡œ ê²Œì„ ì‹œì‘
  startGame();
};

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function getRandomSample(arr, count) {
  if (count >= arr.length) return [...arr];
  const shuffled = [...arr];
  shuffle(shuffled);
  return shuffled.slice(0, count);
}

function startGame() {
  if (!words || words.length === 0) {
    alert('ë‹¨ì–´ ëª©ë¡ì´ ë¡œë”©ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
    return;
  }

  player1 = "Player 1";
  player2 = "Player 2";

  gameSection.classList.remove('hidden');
  gameStarted = true;

  init();
}

function init() {
  board = Array(totalCells).fill(null);
  revealed = Array(totalCells).fill(false);
  wordMap = {};
  foundWords = new Set();
  foundBy = { player1: [], player2: [] };
  currentPlayer = 'player1';
  usedIndexes = new Set();
  clovers.clear();
  daisies.clear();
  wrongGuesses = [];
  wrongListEl.textContent = "";
  wrongGuessesEl.style.display = 'none';
  resultShown = false;

  gameEl.innerHTML = '';
  for (let i = 0; i < totalCells; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.onclick = () => { if (!resultShown) handleClick(i); };
    gameEl.appendChild(cell);
  }

  // ë°©í–¥ ê²€ì¦ê³¼ í•¨ê»˜ ë‹¨ì–´ ë°°ì¹˜
  if (placeAllWordsWithVariety()) {
    console.log('ëª¨ë“  ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤ (3ë°©í–¥ ì‚¬ìš©)');
  } else {
    console.log('ë°©í–¥ ê²€ì¦ ì‹¤íŒ¨ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
    // ê¸°ë³¸ ë°°ì¹˜ ë¡œì§
    let placedWords = [];
    shuffle(words);
    
    for (let word of words) {
      let placed = false;
      for (let attempt = 0; attempt < 500; attempt++) {
        if (placeWord(word)) {
          placedWords.push(word);
          placed = true;
          break;
        }
      }
      if (!placed) {
        console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
      }
    }
    console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
  }

  // í´ë¡œë²„/ë°ì´ì§€ ë°°ì¹˜ (ë‹¨ì–´ ì˜ì—­ í”¼í•˜ê¸°)
  placeDaisies(15);
  placeClovers(30);
  fillEmptyCells();
  updateScore();
  updateTurnDisplay();

  // ê²Œì„ ì¢…ë£Œ ì¡°ê±´ í™•ì¸
  checkGameEnd();
}

function canPlaceWord(word, x, y, dx, dy) {
  for (let i = 0; i < word.length; i++) {
    let nx = x + dx * i, ny = y + dy * i;
    if (nx < 0 || ny < 0 || nx >= gridWidth || ny >= gridHeight) return false;

    let idx = ny * gridWidth + nx;
    if (board[idx] && board[idx] !== word[i]) return false;
    if (usedIndexes.has(idx)) return false;
  }
  return true;
}

function placeWord(word) {
  const directions = [
    { x: 1, y: 0 },   // ê°€ë¡œ (ì˜¤ë¥¸ìª½)
    { x: 0, y: 1 },   // ì„¸ë¡œ (ì•„ë˜)
    { x: 1, y: 1 },   // ëŒ€ê°ì„  (ì˜¤ë¥¸ìª½ ì•„ë˜)
  ];

  // ë°©í–¥ì„ ë¬´ì‘ìœ„ë¡œ ì„ì–´ì„œ ë” ë‹¤ì–‘í•œ ë°°ì¹˜
  const shuffledDirections = directions.sort(() => Math.random() - 0.5);

  for (let dir of shuffledDirections) {
    const startY = Math.floor(Math.random() * gridHeight);
    for (let i = 0; i < gridHeight; i++) {
      const y = (startY + i) % gridHeight;
      for (let x = 0; x < gridWidth; x++) {
        if (canPlaceWord(word, x, y, dir.x, dir.y)) {
          let positions = [];
          for (let i = 0; i < word.length; i++) {
            let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridWidth + nx;
            board[idx] = word[i];
            usedIndexes.add(idx);
            positions.push(idx);
          }
          wordMap[word] = {
            positions: positions,
            direction: [dir.x, dir.y] // ë°©í–¥ ì •ë³´ ì €ì¥
          };
          return true;
        }
      }
    }
  }
  return false;
}

function checkDirectionVariety() {
  let directionCount = {
    '1,0': 0,    // ê°€ë¡œ
    '0,1': 0,    // ì„¸ë¡œ
    '1,1': 0     // ëŒ€ê°ì„ 
  };

  // wordMapì—ì„œ ê° ë‹¨ì–´ì˜ ë°©í–¥ ì²´í¬
  for (let word in wordMap) {
    const direction = wordMap[word].direction;
    const key = direction[0] + ',' + direction[1];
    if (directionCount.hasOwnProperty(key)) {
      directionCount[key]++;
    }
  }

  console.log('ë°©í–¥ë³„ ì‚¬ìš© íšŸìˆ˜:', directionCount);

  // 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ëëŠ”ì§€ í™•ì¸
  return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
}

function placeAllWordsWithVariety() {
  let attempts = 0;
  const maxAttempts = 10;

  do {
    // ì´ˆê¸°í™”
    board = Array(totalCells).fill(null);
    usedIndexes.clear();
    wordMap = {};
    
    // ëª¨ë“  ë‹¨ì–´ ë°°ì¹˜ ì‹œë„
    let allPlaced = true;
    const shuffledWords = [...words].sort(() => Math.random() - 0.5);
    
    for (let word of shuffledWords) {
      if (!placeWord(word)) {
        allPlaced = false;
        break;
      }
    }
    
    if (allPlaced && checkDirectionVariety()) {
      console.log(`ì„±ê³µ! ${attempts + 1}ë²ˆì§¸ ì‹œë„ì—ì„œ 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ë¨`);
      return true; // ì„±ê³µ
    }
    
    attempts++;
    console.log(`${attempts}ë²ˆì§¸ ì‹œë„ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„`);
  } while (attempts < maxAttempts);

  console.log('ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
  return false; // ì‹¤íŒ¨
}

function placeClovers(count) {
  let placed = 0;
  let attempts = 0;
  while (placed < count && attempts < 1000) {
    const idx = Math.floor(Math.random() * totalCells);
    if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
      // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ëŠ”ì§€ í™•ì¸
      if (isSafeForSpecial(idx)) {
        clovers.add(idx);
        placed++;
      }
    }
    attempts++;
  }
  console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
}

function placeDaisies(count) {
  let placed = 0;
  let attempts = 0;
  while (placed < count && attempts < 1000) {
    const idx = Math.floor(Math.random() * totalCells);
    if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
      // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ëŠ”ì§€ í™•ì¸
      if (isSafeForSpecial(idx)) {
        daisies.add(idx);
        placed++;
      }
    }
    attempts++;
  }
  console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
}

function isSafeForSpecial(idx) {
  const x = idx % gridWidth;
  const y = Math.floor(idx / gridWidth);

  // ì£¼ë³€ 8ì¹¸ì— ë‹¤ë¥¸ ì•„ì´í…œì´ ìˆëŠ”ì§€ë§Œ í™•ì¸ (ë‹¨ì–´ëŠ” ìƒê´€ì—†ìŒ)
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
        const nIdx = ny * gridWidth + nx;
        if (clovers.has(nIdx) || daisies.has(nIdx)) {
          return false;
        }
      }
    }
  }
  return true;
}

function fillEmptyCells() {
  const filler = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  shuffle(filler);
  let i = 0;
  for (let j = 0; j < totalCells; j++) {
    if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
      board[j] = filler[i++ % filler.length];
    }
  }
}

function reveal(index) {
  if (revealed[index]) return;
  revealed[index] = true;
  const cell = gameEl.children[index];

  if (clovers.has(index)) {
    cell.textContent = 'ğŸ€';
    // ìƒí•˜ì¢Œìš° 4ì¹¸ ì—´ê¸°
    const directions = [-gridWidth, gridWidth, -1, 1];
    for (let d of directions) {
      const newIdx = index + d;
      if (newIdx >= 0 && newIdx < totalCells) {
        // ì¢Œìš° ì´ë™ ì‹œ ê°™ì€ í–‰ì— ìˆëŠ”ì§€ í™•ì¸
        if (d === -1 || d === 1) {
          if (Math.floor(index / gridWidth) === Math.floor(newIdx / gridWidth)) {
            reveal(newIdx);
          }
        } else {
          reveal(newIdx);
        }
      }
    }
  } else if (daisies.has(index)) {
    cell.textContent = 'ğŸŒ¼';
    // ì£¼ë³€ 8ì¹¸ ëª¨ë‘ ì—´ê¸°
    const x = index % gridWidth;
    const y = Math.floor(index / gridWidth);
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
          const nIdx = ny * gridWidth + nx;
          if (!revealed[nIdx]) reveal(nIdx);
        }
      }
    }
  } else {
    cell.textContent = board[index];
  }
  cell.classList.add('revealed');
}

function updateScore() {
  player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `âœ“ ${w}`).join("<br>");
  player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `âœ“ ${w}`).join("<br>");
}

function updateTurnDisplay() {
  if (!gameStarted) return;
  currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
  currentTurnEl.textContent = `${currentPlayerName}ë‹˜ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤`;
}

function switchTurn(extra) {
  if (!extra) {
    currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
  }
  updateTurnDisplay();
}

function handleClick(index) {
  if (revealed[index] || resultShown || !gameStarted) return;

  const extra = clovers.has(index) || daisies.has(index);
  reveal(index);
  checkWords();
  checkGameEnd();

  if (!resultShown) {
    switchTurn(extra);
  }
}

function checkWords() {
  for (let word of Object.keys(wordMap)) {
    if (foundWords.has(word)) continue;
    const pos = wordMap[word].positions;
    if (pos.every(i => revealed[i])) {
      foundWords.add(word);
      foundBy[currentPlayer].push(word);
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
      });
      updateScore();
    }
  }
}

function checkGameEnd() {
  const totalWords = Object.keys(wordMap).length;
  if (foundWords.size >= totalWords && totalWords > 0) {
    resultShown = true;
    setTimeout(() => {
      const player1Score = foundBy.player1.length;
      const player2Score = foundBy.player2.length;
      let winner = player1Score > player2Score ? player1 : 
                   player2Score > player1Score ? player2 : "draw";
      
      if (winner === "draw") {
        alert(`Game Over!\n${player1}: ${player1Score} points\n${player2}: ${player2Score} points\nDraw!`);
      } else {
        alert(`Game Over!\n${player1}: ${player1Score} points\n${player2}: ${player2Score} points\n${winner} Wins!`);
      }
    }, 500);
  }
}

function handleGuess() {
  if (!gameStarted) return;

  const guess = guessInput.value.trim().toUpperCase();
  guessInput.value = "";
  if (!guess || foundWords.has(guess)) return;

  if (wordMap[guess]) {
    const pos = wordMap[guess].positions;
    pos.forEach(i => {
      if (!revealed[i]) reveal(i);
    });
    foundWords.add(guess);
    foundBy[currentPlayer].push(guess);
    pos.forEach(i => {
      const cell = gameEl.children[i];
      cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
    });
    updateScore();
    checkGameEnd();
  } else {
    if (!wrongGuesses.includes(guess)) {
      wrongGuesses.push(guess);
      wrongListEl.textContent = wrongGuesses.join(", ");
      wrongGuessesEl.style.display = 'block';
    }
  }

  if (!resultShown) {
    switchTurn(false);
  }
}

function retry() {
  if (!gameStarted) return;
  init();
}

function backToSetup() {
  gameStarted = false;
  // ê²Œì„ ì´ˆê¸°í™”
  guessInput.value = "";
  wrongGuesses = [];
  wrongListEl.textContent = "";
  wrongGuessesEl.style.display = 'none';
  
  // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ì™„ì „ ì´ˆê¸°í™”
  location.reload();
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
retryBtn.onclick = retry;
backBtn.onclick = backToSetup;
guessBtn.onclick = handleGuess;
guessInput.addEventListener('keypress', e => {
  if (e.key === 'Enter') handleGuess();
});
</script>

</body>
</html>
