<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WORPUZZMATE LARGE</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f0f8f7;
      margin: 0;
      padding: 20px;
      color: #333;
      text-align: center;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 10px;
      font-weight: bold;
      color: #064d4d;
    }
    p {
      font-size: 14px;
      margin-bottom: 20px;
      color: #064d4d;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .player-input input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 150px;
      text-align: center;
    }
    .guess-section {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .guess-section input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #aaa;
      border-radius: 4px;
      width: 300px;
    }
    .game-area {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .game-button {
      font-size: 18px;
      background-color: #c8f4ee;
      padding: 10px 22px;
      margin: 8px;
      color: #064d4d;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .game-button:hover {
      background-color: #1d9e95;
      transform: scale(1.05);
    }
    .cell {
      width: 38px;
      height: 38px;
      background-color: #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
      border: 1px solid #999;
    }
    .revealed { background-color: #fff; }
    .word-owned-player1 { background-color: #b7d5f2; }
    .word-owned-player2 { background-color: #f6c28b; }
    #player1Score, #player2Score {
      width: 160px;
      min-height: 300px;
      padding: 10px;
      font-size: 20px;
      font-weight: bold;
      border: 2px solid #333;
    }
    #player1Score { background-color:  #b7d5f2; }
    #player2Score { background-color: #f6c28b; }
    #currentTurn {
      font-size: 20px;
      margin: 10px;
      color: #056762;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(19, 50px);
      grid-gap: 5px;
      padding: 10px;
      border: 2px solid #333;
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
    .inline { display: inline; }

  </style>
</head>

<body>

<h1 id="game-title">게임 제목</h1>
<p id="game-desc">게임 설명</p>

<div class="game-container">

    <div id="gameSection" class="hidden">
    <div id="currentTurn"></div>

<div class="guess-section">
  <input type="text" id="guessInput" placeholder="YOUR GUESS(UPPERCASE)" />
  <button id="guessBtn" class="game-button">SUBMIT</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>Invalid words:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

<div class="controls">
  <button id="retryBtn" class="game-button">RETRY</button>
  <button onclick="location.href='index.html'" class="game-button">HOME</button>
</div>


  </div>

</div>
<script>
// 전역 변수 선언을 함수 밖으로 이동하고 let으로 변경
const gridSize = 19;
const gridHeight = 12;
const totalCells = gridSize * gridHeight;

let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
let player1 = “플레이어1”, player2 = “플레이어2”, currentPlayerName = “”, wrongGuesses = [];

// DOM 요소 참조
const gameEl = document.getElementById(‘game’);
const player1ScoreEl = document.getElementById(‘player1Score’);
const player2ScoreEl = document.getElementById(‘player2Score’);
const retryBtn = document.getElementById(‘retryBtn’);
const startBtn = document.getElementById(‘startBtn’);
const gameSection = document.getElementById(‘gameSection’);
const currentTurnEl = document.getElementById(‘currentTurn’);
const guessInput = document.getElementById(‘guessInput’);
const guessBtn = document.getElementById(‘guessBtn’);
const wrongListEl = document.getElementById(‘wrongList’);
const wrongGuessesEl = document.getElementById(‘wrongGuesses’);

window.onload = () => {
const urlParams = new URLSearchParams(window.location.search);
const poolFile = urlParams.get(‘pool’);

if (!poolFile) {
// 기본 단어들 설정
words = [‘CAT’, ‘GAME’, ‘PLAY’, ‘WORD’, ‘PUZZLE’, ‘FIND’, ‘CLICK’, ‘DOG’];
// startGame을 호출하지 않고 사용자가 버튼을 누르도록 함
return;
}

fetch(‘wordpools/’ + poolFile + ‘.json’)
.then(res => {
if (!res.ok) {
throw new Error(`HTTP error! status: ${res.status}`);
}
return res.json();
})
.then(data => {
document.getElementById(‘game-title’).textContent = data.title || ‘게임 제목’;
const rawText = data.description || ‘게임 설명’;
const htmlText = rawText.replace(/\n/g, ‘<br>’);
document.getElementById(‘game-desc’).innerHTML = htmlText;


  words = [];
  for (let length in data.words) {
    const count = data.wordCount[length] || 0;
    if (data.words[length] && Array.isArray(data.words[length])) {
      words.push(...getRandomSample(data.words[length], count));
    }
  }
  console.log('총 단어 수:', words.length);
  console.log('단어 목록:', words);
})
  startGame(); // 여기에!
})

.catch(err => {
  console.error('파일 로드 실패:', err);


  // 에러 발생 시 긴 단어들을 포함한 기본 단어들로 진행
  words = [
    'GRANDFATHER', 'GRANDMOTHER', 'GRANDPARENT', 'INTERESTING', 
    'SUPERMARKET', 'CONVERSATION', 'INFORMATION', 'DESCRIPTION',
    'UNDERSTANDING', 'INTERNATIONAL', 'ENTERTAINMENT', 'DEVELOPMENT',
    'HELLO', 'WORLD', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'SEARCH'
  ];
});


};

function shuffle(arr) {
for (let i = arr.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[arr[i], arr[j]] = [arr[j], arr[i]];
}
}

function getRandomSample(arr, count) {
if (count >= arr.length) return […arr];
const shuffled = […arr];
shuffle(shuffled);
return shuffled.slice(0, count);
}

function startGame() {
// 단어가 로드되지 않았으면 기본 단어 사용
if (!words || words.length === 0) {
words = [‘CAT’, ‘GAME’, ‘PLAY’, ‘WORD’, ‘PUZZLE’, ‘FIND’, ‘CLICK’, ‘DOG’];
}

player1 = document.getElementById(‘player1Name’).value.trim() || “플레이어1”;
player2 = document.getElementById(‘player2Name’).value.trim() || “플레이어2”;

gameSection.classList.remove(‘hidden’);
gameStarted = true;

init();
}

function init() {
board = Array(totalCells).fill(null);
revealed = Array(totalCells).fill(false);
wordMap = {};
foundWords = new Set();
foundBy = { player1: [], player2: [] };
currentPlayer = ‘player1’;
usedIndexes = new Set();
clovers.clear();
daisies.clear();
wrongGuesses = [];
wrongListEl.textContent = “”;
wrongGuessesEl.style.display = ‘none’;
resultShown = false;

gameEl.innerHTML = ‘’;
for (let i = 0; i < totalCells; i++) {
const cell = document.createElement(‘div’);
cell.className = ‘cell’;
cell.onclick = () => { if (!resultShown) handleClick(i); };
gameEl.appendChild(cell);
}

// 방향 검증과 함께 단어 배치
if (placeAllWordsWithVariety()) {
console.log(‘모든 단어가 성공적으로 배치되었습니다 (3방향 사용)’);
} else {
console.log(‘방향 검증 실패 - 기본 배치로 진행’);
// 기본 배치 로직
let placedWords = [];
shuffle(words);


for (let word of words) {
  let placed = false;
  for (let attempt = 0; attempt < 500; attempt++) {
    if (placeWord(word)) {
      placedWords.push(word);
      placed = true;
      break;
    }
  }
  if (!placed) {
    console.log('배치 실패한 단어:', word);
  }
}
console.log('실제 배치된 단어 수:', placedWords.length);


}

// 클로버/데이지 배치 (단어 영역 피하기)
placeDaisies(15);
placeClovers(30);
fillEmptyCells();
updateScore();
updateTurnDisplay();

// 게임 종료 조건 확인
checkGameEnd();
}

function canPlaceWord(word, x, y, dx, dy) {
// 경계 체크 수정: gridHeight 사용
for (let i = 0; i < word.length; i++) {
let nx = x + dx * i, ny = y + dy * i;
if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridHeight) return false;


let idx = ny * gridSize + nx;
if (board[idx] && board[idx] !== word[i]) return false;
if (usedIndexes.has(idx)) return false;


}
return true;
}

function placeWord(word) {
const directions = [
{ x: 1, y: 0 },   // 가로 (오른쪽)
{ x: 0, y: 1 },   // 세로 (아래)
{ x: 1, y: 1 },   // 대각선 (오른쪽 아래)
];

// 방향을 무작위로 섞어서 더 다양한 배치
const shuffledDirections = directions.sort(() => Math.random() - 0.5);

for (let dir of shuffledDirections) {
// gridHeight 사용하도록 수정
const startY = Math.floor(Math.random() * gridHeight);
for (let i = 0; i < gridHeight; i++) {
const y = (startY + i) % gridHeight;
for (let x = 0; x < gridSize; x++) {
if (canPlaceWord(word, x, y, dir.x, dir.y)) {
let positions = [];
for (let i = 0; i < word.length; i++) {
let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
board[idx] = word[i];
usedIndexes.add(idx);
positions.push(idx);
}
wordMap[word] = {
positions: positions,
direction: [dir.x, dir.y]
};
return true;
}
}
}
}
return false;
}

function checkDirectionVariety() {
let directionCount = {
‘1,0’: 0,    // 가로
‘0,1’: 0,    // 세로
‘1,1’: 0     // 대각선
};

for (let word in wordMap) {
const direction = wordMap[word].direction;
const key = direction[0] + ‘,’ + direction[1];
if (directionCount.hasOwnProperty(key)) {
directionCount[key]++;
}
}

console.log(‘방향별 사용 횟수:’, directionCount);

return directionCount[‘1,0’] > 0 && directionCount[‘0,1’] > 0 && directionCount[‘1,1’] > 0;
}

function placeAllWordsWithVariety() {
let attempts = 0;
const maxAttempts = 10;

do {
// 초기화
board = Array(totalCells).fill(null);
usedIndexes.clear();
wordMap = {};


// 모든 단어 배치 시도
let allPlaced = true;
const shuffledWords = [...words].sort(() => Math.random() - 0.5);

for (let word of shuffledWords) {
  if (!placeWord(word)) {
    allPlaced = false;
    break;
  }
}

if (allPlaced && checkDirectionVariety()) {
  console.log(`성공! ${attempts + 1}번째 시도에서 3방향 모두 사용됨`);
  return true;
}

attempts++;
console.log(`${attempts}번째 시도 실패 - 다시 시도`);


} while (attempts < maxAttempts);

console.log(‘최대 시도 횟수 초과 - 기본 배치로 진행’);
return false;
}

function placeClovers(count) {
let placed = 0;
let attempts = 0;
while (placed < count && attempts < 1000) {
const idx = Math.floor(Math.random() * totalCells);
if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
if (isSafeForSpecial(idx)) {
clovers.add(idx);
placed++;
}
}
attempts++;
}
console.log(‘배치된 클로버 수:’, clovers.size);
}

function placeDaisies(count) {
let placed = 0;
let attempts = 0;
while (placed < count && attempts < 1000) {
const idx = Math.floor(Math.random() * totalCells);
if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
if (isSafeForSpecial(idx)) {
daisies.add(idx);
placed++;
}
}
attempts++;
}
console.log(‘배치된 데이지 수:’, daisies.size);
}

function isSafeForSpecial(idx) {
const x = idx % gridSize;
const y = Math.floor(idx / gridSize);

// 주변 8칸에 다른 아이템이 있는지만 확인 (단어는 상관없음)
for (let dy = -1; dy <= 1; dy++) {
for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;
const nx = x + dx;
const ny = y + dy;
if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridHeight) {
const nIdx = ny * gridSize + nx;
if (clovers.has(nIdx) || daisies.has(nIdx)) {
return false;
}
}
}
}
return true;
}

function fillEmptyCells() {
const filler = ‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’.split(’’);
shuffle(filler);
let i = 0;
for (let j = 0; j < totalCells; j++) {
if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
board[j] = filler[i++ % filler.length];
}
}
}

function reveal(index) {
if (revealed[index]) return;
revealed[index] = true;
const cell = gameEl.children[index];

if (clovers.has(index)) {
cell.textContent = ‘🍀’;
// 상하좌우 4칸 열기
const directions = [-gridSize, gridSize, -1, 1];
for (let d of directions) {
const newIdx = index + d;
if (newIdx >= 0 && newIdx < totalCells) {
// 좌우 이동 시 같은 행에 있는지 확인
if (d === -1 || d === 1) {
if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
reveal(newIdx);
}
} else {
reveal(newIdx);
}
}
}
} else if (daisies.has(index)) {
cell.textContent = ‘🌼’;
// 주변 8칸 모두 열기
const x = index % gridSize;
const y = Math.floor(index / gridSize);
for (let dy = -1; dy <= 1; dy++) {
for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;
const nx = x + dx;
const ny = y + dy;
if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridHeight) {
const nIdx = ny * gridSize + nx;
if (!revealed[nIdx]) reveal(nIdx);
}
}
}
} else {
cell.textContent = board[index];
}
cell.classList.add(‘revealed’);
}

function updateScore() {
player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `✓ ${w}`).join(”<br>”);
player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `✓ ${w}`).join(”<br>”);
}

function updateTurnDisplay() {
if (!gameStarted) return;
currentPlayerName = currentPlayer === ‘player1’ ? player1 : player2;
currentTurnEl.textContent = `It is ${currentPlayerName}'s turn.`;
}

function switchTurn(extra) {
if (!extra) {
currentPlayer = currentPlayer === ‘player1’ ? ‘player2’ : ‘player1’;
}
updateTurnDisplay();
}

function handleClick(index) {
if (revealed[index] || resultShown || !gameStarted) return;

const extra = clovers.has(index) || daisies.has(index);
reveal(index);
checkWords();
checkGameEnd();

if (!resultShown) {
switchTurn(extra);
}
}

function checkWords() {
for (let word of Object.keys(wordMap)) {
if (foundWords.has(word)) continue;
const pos = wordMap[word].positions;
if (pos.every(i => revealed[i])) {
foundWords.add(word);
foundBy[currentPlayer].push(word);
pos.forEach(i => {
const cell = gameEl.children[i];
cell.classList.add(currentPlayer === ‘player1’ ? ‘word-owned-player1’ : ‘word-owned-player2’);
});
updateScore();
}
}
}

function checkGameEnd() {
const totalWords = Object.keys(wordMap).length;
if (foundWords.size >= totalWords && totalWords > 0) {
resultShown = true;


setTimeout(() => {
  const player1Score = foundBy.player1.length;
  const player2Score = foundBy.player2.length;
  let winner;
  
  if (player1Score > player2Score) {
    winner = player1;
  } else if (player2Score > player1Score) {
    winner = player2;
  } else {
    winner = "무승부";
  }
  
  alert(`게임 종료!\n${player1}: ${player1Score}개\n${player2}: ${player2Score}개\n승자: ${winner}`);
}, 500);


}
}

function handleGuess() {
if (!gameStarted) return;

const guess = guessInput.value.trim().toUpperCase(); // 대문자로 변환
guessInput.value = “”;
if (!guess || foundWords.has(guess)) return;

if (wordMap[guess]) {
const pos = wordMap[guess].positions;
pos.forEach(i => {
if (!revealed[i]) reveal(i);
});
foundWords.add(guess);
foundBy[currentPlayer].push(guess);
pos.forEach(i => {
const cell = gameEl.children[i];
cell.classList.add(currentPlayer === ‘player1’ ? ‘word-owned-player1’ : ‘word-owned-player2’);
});
updateScore();
checkGameEnd();
} else {
if (!wrongGuesses.includes(guess)) {
wrongGuesses.push(guess);
wrongListEl.textContent = wrongGuesses.join(”, “);
wrongGuessesEl.style.display = ‘block’;
}
}

if (!resultShown) {
switchTurn(false);
}
}

function retry() {
if (!gameStarted) return;
init();
}

// 이벤트 리스너 등록
retryBtn.onclick = retry;
guessBtn.onclick = handleGuess;
guessInput.addEventListener(‘keypress’, e => {
if (e.key === ‘Enter’) handleGuess();
});
</script>

</body>
</html>
