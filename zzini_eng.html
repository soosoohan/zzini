<!DOCTYPE html>

<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4YZHC1G9FN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-4YZHC1G9FN');
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="format-detection" content="telephone=no" />

  <title>ì›Œí¼ì¦ˆì°Œë‹ˆì˜ì–´</title>
  <style>
          * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }


  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    position: fixed;
    width: 100%;
    -webkit-overflow-scrolling: touch;
  }
  
  body {
    font-family: 'Noto Sans KR', sans-serif;
    background-color: #f0f8f7;
    color: #333;
    text-align: center;
    padding: 10px;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
     .screen-warning {
      display: none;
      text-align: center;
      padding: 40px;
      font-family: Arial, sans-serif;
      max-width: 400px;
      margin: 100px auto;
      background-color: #f8f9fa;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .screen-warning h2 {
      color: #dc3545;
      margin-bottom: 20px;
    }
    
    .screen-warning p {
      color: #666;
      line-height: 1.6;
    }
   h1 {
    font-size: clamp(18px, 4vw, 24px);
    font-weight: bold;
    color: #064d4d;
    margin: 5px;
  }
  
  p {
    font-size: clamp(14px, 3vw, 18px);
    color: #064d4d;
    margin: 5px;
}
    .game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
    max-width: 100vw;
    overflow: hidden;
  }
  
  .player-input input {
    font-size: clamp(16px, 3vw, 18px);
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: clamp(120px, 30vw, 150px);
    text-align: center;
  }
  
  .start-section {
    margin-bottom: 10px;
  }
  
  .guess-section {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    flex-wrap: wrap;
    padding: 0 10px;
  }
  
  .guess-section input {
    font-size: clamp(16px, 3vw, 18px);
    padding: 6px;
    border: 1px solid #aaa;
    border-radius: 4px;
    width: clamp(150px, 40vw, 200px);
    min-width: 150px;
  }
  
  .game-area {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: clamp(8px, 2vw, 15px);
    margin-bottom: 10px;
    width: 100%;
    max-width: 100vw;
    overflow: hidden;
  }
  
  .game-button {
    font-size: clamp(14px, 3vw, 16px);
    background-color: #c8f4ee;
    padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 18px);
    margin: 4px;
    color: #064d4d;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    touch-action: manipulation;
    white-space: nowrap;
  }
  
  .game-button:hover, .game-button:active {
    background-color: #1d9e95;
    transform: scale(1.02);
  }
  
  .cell {
    width: 100%;
    height: 100%;
    background-color: #ddd;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5em;
    cursor: pointer;
    border: 1px solid #999;
    touch-action: manipulation;
  }
  
  .revealed { 
    background-color: #fff; 
   font-size: 1.5em;
 
  }
  
  .word-owned-player1 { 
    background-color: #b7d5f2; 
  }
  
  .word-owned-player2 { 
    background-color: #f6c28b; 
  }
  
  #player1Score, #player2Score {
    width: 180px;
    height: 480px;
    padding: 8px;
    font-size: 1.2em;
    font-weight: bold;
    border: 2px solid #333;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  
  #player1Score { 
    background-color: #b7d5f2; 
  }
  
  #player2Score { 
    background-color: #f6c28b; 
  }
  
  #currentTurn {
    font-size: clamp(14px, 3vw, 18px);
    margin: 8px;
    color: #056762;
    font-weight: bold;
  }
  
  #game {
    display: grid;
    grid-template-columns: repeat(19,1fr);
    grid-template-rows:repeat(12,1fr);
    grid-gap: 4px;
    padding: 8px;
    border: 2px solid #333;
    background-color: #eee;
    width: 757px;
    height:480px;
  }
  
  .hidden {
    display: none;
  }
  
  .controls {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  #wrongGuesses {
    font-size: clamp(12px, 2.5vw, 14px);
    margin: 5px 0;
    padding: 0 10px;
    word-wrap: break-word;
  }
.inline { display: inline; }
  
  /* ì•„ì´íŒ¨ë“œ ì„¸ë¡œ ëª¨ë“œ ìµœì í™” */
  @media screen and (max-width: 1300px) and (orientation: portrait) {
    body {
      padding: 5px;
    }
    
    .game-area {
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    #player1Score, #player2Score {
      width: 757px;
      height: auto;
      display: flex;
      flex-direction: column;
      order: 3;
    }
    
    #game {
      order: 1;
      margin-bottom: 10px;
    }
    
    #currentTurn {
      order: 2;
    } 
  }
  
  
</style>
</head>

<body>
  
    <div class="screen-warning" id="warning">
    <h2>Screen Too Small</h2>
    <p>This game is a mode where two users compete on a large grid, designed to be played on screens of at least 800px or larger.
</p>
    <p>For screens smaller than 800px, please use Worpuzzmate.</p>
    <p>ì´ ê²Œì„ì€ ë‘ ì‚¬ìš©ìê°€ í° ê²©ìì—ì„œ ëŒ€ê²°í•˜ëŠ” ëª¨ë“œë¡œ  ìµœì†Œ 800px ì´ìƒì˜ í™”ë©´ì—ì„œ í”Œë ˆì´í•˜ë„ë¡ ë””ìì¸ë˜ì—ˆìŠµë‹ˆë‹¤</p>
    <p>800px ë³´ë‹¤ ì‘ì€ í™”ë©´ì—ì„œëŠ” ì›Œí¼ì¦ˆë©”ì´íŠ¸ë¥¼ ì´ìš©í•˜ì„¸ìš”</p>
 <button onclick="location.href='https://worpuzzmate.vercel.app'" class="game-button">Play Worpuzzmate<br> ì›Œí¼ì¦ˆë©”ì´íŠ¸ í•˜ëŸ¬ê°€ê¸°</button>
  </div>

<h1 id="game-title">ê²Œì„ ì œëª©</h1>
<p id="game-desc">ê²Œì„ ì„¤ëª…</p>

<div class="game-container" id="game-container">

  <div id="gameSection" class="hidden">
    <div id="currentTurn"></div>


<div class="guess-section">
  <input type="text" id="guessInput" placeholder="YOUR GUESS(UPPERCASE)" />
  <button id="guessBtn" class="game-button">SUBMIT</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>Invalid words:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

<div class="controls">
  <button id="retryBtn" class="game-button">RETRY</button>
  <button onclick="location.href='index.html'" class="game-button">HOME</button>
</div>


  </div>

</div>
<script>
function checkScreenSize() {
  const warning = document.getElementById('warning');
  const body = document.body;
  
  if (window.innerWidth < 800) {
    warning.style.display = 'block';
    document.getElementById('game-title').style.display = 'none';
    document.getElementById('game-desc').style.display = 'none';
    document.querySelector('.game-container').style.display = 'none';
  } else {
    warning.style.display = 'none';
    document.getElementById('game-title').style.display = 'inline';
    document.getElementById('game-desc').style.display = 'inline';
    document.querySelector('.game-container').style.display = 'flex';
  }
}
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì²´í¬
    checkScreenSize();
    
    // í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ ì²´í¬
    window.addEventListener('resize', checkScreenSize);
  // ì¤Œ/ìŠ¤í¬ë¡¤ ë°©ì§€ë¥¼ ìœ„í•œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
document.addEventListener('touchmove', function(e) {
  if (e.scale !== 1) {
    e.preventDefault();
  }
}, { passive: false });

document.addEventListener('gesturestart', function(e) {
  e.preventDefault();
});

document.addEventListener('gesturechange', function(e) {
  e.preventDefault();
});

document.addEventListener('gestureend', function(e) {
  e.preventDefault();
});

// ë”ë¸”íƒ­ ì¤Œ ë°©ì§€
let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
  const now = (new Date()).getTime();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, false);

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    // ì„ì‹œë¡œ ê¸°ë³¸ ë‹¨ì–´ë“¤ ì„¤ì •
  words = ['CAT', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'CLICK', 'DOG'];
    gameSection.classList.remove('hidden');
    init();
    return;
  }

  fetch('wordpools/' + poolFile + '.json')
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || 'ê²Œì„ ì œëª©';
      const rawText = data.description || 'ê²Œì„ ì„¤ëª…';
      const htmlText = rawText.replace(/\n/g, '<br>');
      document.getElementById('game-desc').innerHTML = htmlText; // innerHTMLë¡œ ë³€ê²½

      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        words.push(...getRandomSample(data.words[length], count));
      }
        console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
  console.log('ë‹¨ì–´ ëª©ë¡:', words);
  
  startGame(); // ì—¬ê¸°ì—!
})
.catch(err => {
  document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message + '</p>';
});


  const gridWidth = 19;
  const gridHeight = 12;
  const totalCells = gridWidth * gridHeight;
  let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
  let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
  let player1 = "í”Œë ˆì´ì–´1", player2 = "í”Œë ˆì´ì–´2", currentPlayerName = "", wrongGuesses = [];

  const gameEl = document.getElementById('game');
  const player1ScoreEl = document.getElementById('player1Score');
  const player2ScoreEl = document.getElementById('player2Score');
  const retryBtn = document.getElementById('retryBtn');
  const startBtn = document.getElementById('startBtn');
  const gameSection = document.getElementById('gameSection');
  const currentTurnEl = document.getElementById('currentTurn');
  const guessInput = document.getElementById('guessInput');
  const guessBtn = document.getElementById('guessBtn');
  const wrongListEl = document.getElementById('wrongList');
  const wrongGuessesEl = document.getElementById('wrongGuesses');

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function getRandomSample(arr, count) {
    if (count >= arr.length) return [...arr];
    const shuffled = [...arr];
    shuffle(shuffled);
    return shuffled.slice(0, count);
  }

   function startGame() {
     player1 = "player1";
     player2 = "player2";
    gameSection.classList.remove('hidden');
    gameStarted = true;
    
    init();
  }

  function init() {
    board = Array(totalCells).fill(null);
    revealed = Array(totalCells).fill(false);
    wordMap = {};
    foundWords = new Set();
    foundBy = { player1: [], player2: [] };
    currentPlayer = 'player1';
    usedIndexes = new Set();
    clovers.clear();
    daisies.clear();
    wrongGuesses = [];
    wrongListEl.textContent = "";
    wrongGuessesEl.style.display = 'none';
    resultShown = false;

    gameEl.innerHTML = '';
    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.onclick = () => { if (!resultShown) handleClick(i); };
      gameEl.appendChild(cell);
    }

    // ë°©í–¥ ê²€ì¦ê³¼ í•¨ê»˜ ë‹¨ì–´ ë°°ì¹˜
    if (placeAllWordsWithVariety()) {
      console.log('ëª¨ë“  ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤ (3ë°©í–¥ ì‚¬ìš©)');
    } else {
      console.log('ë°©í–¥ ê²€ì¦ ì‹¤íŒ¨ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
      // ê¸°ë³¸ ë°°ì¹˜ ë¡œì§
      let placedWords = [];
      shuffle(words);
      
      for (let word of words) {
        let placed = false;
        for (let attempt = 0; attempt < 500; attempt++) {
          if (placeWord(word)) {
            placedWords.push(word);
            placed = true;
            break;
          }
        }
        if (!placed) {
          console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
        }
      }
      console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
    }
    
    // í´ë¡œë²„/ë°ì´ì§€ ë°°ì¹˜ (ë‹¨ì–´ ì˜ì—­ í”¼í•˜ê¸°)
    placeDaisies(15);
    placeClovers(30);
    fillEmptyCells();
    updateScore();
    updateTurnDisplay();
    
    // ê²Œì„ ì¢…ë£Œ ì¡°ê±´ í™•ì¸
    checkGameEnd();
  }

  function canPlaceWord(word, x, y, dx, dy) {
    for (let i = 0; i < word.length; i++) {
      let nx = x + dx * i, ny = y + dy * i;
      if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return false;
      
      let idx = ny * gridSize + nx;
      if (board[idx] && board[idx] !== word[i]) return false;
      if (usedIndexes.has(idx)) return false;
    }
    return true;
  }

  function placeWord(word) {
    const directions = [
      { x: 1, y: 0 },   // ê°€ë¡œ (ì˜¤ë¥¸ìª½)
      { x: 0, y: 1 },   // ì„¸ë¡œ (ì•„ë˜)
      { x: 1, y: 1 },   // ëŒ€ê°ì„  (ì˜¤ë¥¸ìª½ ì•„ë˜)
    ];
    
    // ë°©í–¥ì„ ë¬´ì‘ìœ„ë¡œ ì„ì–´ì„œ ë” ë‹¤ì–‘í•œ ë°°ì¹˜
    const shuffledDirections = directions.sort(() => Math.random() - 0.5);
   
    for (let dir of shuffledDirections) {
const startY = Math.floor(Math.random() * gridSize);
for (let i = 0; i < gridSize; i++) {
  const y = (startY + i) % gridSize;
  for (let x = 0; x < gridSize; x++) {

          

if (canPlaceWord(word, x, y, dir.x, dir.y)) {
            let positions = [];
            for (let i = 0; i < word.length; i++) {
              let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
              board[idx] = word[i];
              usedIndexes.add(idx);
              positions.push(idx);
            }
            wordMap[word] = {
              positions: positions,
              direction: [dir.x, dir.y] // ë°©í–¥ ì •ë³´ ì €ì¥
            };
            return true;
          }
        }
      }
    }
    return false;
  }

  function checkDirectionVariety() {
    let directionCount = {
      '1,0': 0,    // ê°€ë¡œ
      '0,1': 0,    // ì„¸ë¡œ
      '1,1': 0     // ëŒ€ê°ì„ 
    };
    
    // wordMapì—ì„œ ê° ë‹¨ì–´ì˜ ë°©í–¥ ì²´í¬
    for (let word in wordMap) {
      const direction = wordMap[word].direction;
      const key = direction[0] + ',' + direction[1];
      if (directionCount.hasOwnProperty(key)) {
        directionCount[key]++;
      }
    }
    
    console.log('ë°©í–¥ë³„ ì‚¬ìš© íšŸìˆ˜:', directionCount);
    
    // 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ëëŠ”ì§€ í™•ì¸
    return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
  }

  function placeAllWordsWithVariety() {
    let attempts = 0;
    const maxAttempts = 10;
    
    do {
      // ì´ˆê¸°í™”
      board = Array(totalCells).fill(null);
      usedIndexes.clear();
      wordMap = {};
      
      // ëª¨ë“  ë‹¨ì–´ ë°°ì¹˜ ì‹œë„
      let allPlaced = true;
      const shuffledWords = [...words].sort(() => Math.random() - 0.5);
      
      for (let word of shuffledWords) {
        if (!placeWord(word)) {
          allPlaced = false;
          break;
        }
      }
      
      if (allPlaced && checkDirectionVariety()) {
        console.log(`ì„±ê³µ! ${attempts + 1}ë²ˆì§¸ ì‹œë„ì—ì„œ 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ë¨`);
        return true; // ì„±ê³µ
      }
      
      attempts++;
      console.log(`${attempts}ë²ˆì§¸ ì‹œë„ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„`);
    } while (attempts < maxAttempts);
    
    console.log('ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
    return false; // ì‹¤íŒ¨
  }

  function placeClovers(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ëŠ”ì§€ í™•ì¸
        

if (isSafeForSpecial(idx)) {
          clovers.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
  }

  function placeDaisies(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ëŠ”ì§€ í™•ì¸
        if (isSafeForSpecial(idx)) {
          daisies.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
  }
function isSafeForSpecial(idx) {
  const x = idx % gridSize;
  const y = Math.floor(idx / gridSize);
  
  // ì£¼ë³€ 8ì¹¸ì— ë‹¤ë¥¸ ì•„ì´í…œì´ ìˆëŠ”ì§€ë§Œ í™•ì¸ (ë‹¨ì–´ëŠ” ìƒê´€ì—†ìŒ)
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
        const nIdx = ny * gridSize + nx;
        if (clovers.has(nIdx) || daisies.has(nIdx)) {
          return false;
        }
      }
    }
  }
  return true;
}


  function fillEmptyCells() {
    const filler = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    shuffle(filler);
    let i = 0;
    for (let j = 0; j < totalCells; j++) {
      if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
        board[j] = filler[i++ % filler.length];
      }
    }
  }

  function reveal(index) {
    if (revealed[index]) return;
    revealed[index] = true;
    const cell = gameEl.children[index];
    
    if (clovers.has(index)) {
      cell.textContent = 'ğŸ€';
      // ìƒí•˜ì¢Œìš° 4ì¹¸ ì—´ê¸°
      const directions = [-gridSize, gridSize, -1, 1];
      for (let d of directions) {
        const newIdx = index + d;
        if (newIdx >= 0 && newIdx < totalCells) {
          // ì¢Œìš° ì´ë™ ì‹œ ê°™ì€ í–‰ì— ìˆëŠ”ì§€ í™•ì¸
          if (d === -1 || d === 1) {
            if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
              reveal(newIdx);
            }
          } else {
            reveal(newIdx);
          }
        }
      }
    } else if (daisies.has(index)) {
      cell.textContent = 'ğŸŒ¼';
      // ì£¼ë³€ 8ì¹¸ ëª¨ë‘ ì—´ê¸°
      const x = index % gridSize;
      const y = Math.floor(index / gridSize);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const nIdx = ny * gridSize + nx;
            if (!revealed[nIdx]) reveal(nIdx);
          }
        }
      }
    } else {
      cell.textContent = board[index];
    }
    cell.classList.add('revealed');
  }

  function updateScore() {
    player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `âœ“ ${w}`).join("<br>");
    player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `âœ“ ${w}`).join("<br>");
  }

  function updateTurnDisplay() {
    if (!gameStarted) return;
    currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
    currentTurnEl.textContent = `It is ${currentPlayerName}'s turn.`;
  }

  function switchTurn(extra) {
    if (!extra) {
      currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
    }
    updateTurnDisplay();
  }

  function handleClick(index) {
    if (revealed[index] || resultShown || !gameStarted) return;
    
    const extra = clovers.has(index) || daisies.has(index);
    reveal(index);
    checkWords();
    checkGameEnd();
    
    if (!resultShown) {
      switchTurn(extra);
    }
  }

  function checkWords() {
    for (let word of Object.keys(wordMap)) {
      if (foundWords.has(word)) continue;
      const pos = wordMap[word].positions; // .positions ì¶”ê°€
      if (pos.every(i => revealed[i])) {
        foundWords.add(word);
        foundBy[currentPlayer].push(word);
        pos.forEach(i => {
          const cell = gameEl.children[i];
          cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
        });
        updateScore();
      }
    }
  }

  function checkGameEnd() {
    const totalWords = Object.keys(wordMap).length;
    if (foundWords.size >= totalWords && totalWords > 0) {
      resultShown = true;
      
      setTimeout(() => {
        alert("game over!");
      }, 500);
    }
  } 

  function handleGuess() {
    if (!gameStarted) return;
    
    const guess = guessInput.value.trim();
    guessInput.value = "";
    if (!guess || foundWords.has(guess)) return;
    
    if (wordMap[guess]) {
      const pos = wordMap[guess].positions; // .positions ì¶”ê°€
      pos.forEach(i => {
        if (!revealed[i]) reveal(i);
      });
      foundWords.add(guess);
      foundBy[currentPlayer].push(guess);
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
      });
      updateScore();
      checkGameEnd();
    } else {
      if (!wrongGuesses.includes(guess)) {
        wrongGuesses.push(guess);
        wrongListEl.textContent = wrongGuesses.join(", ");
        wrongGuessesEl.style.display = 'block';
      }
    }
    
    if (!resultShown) {
      switchTurn(false);
    }
  }

  function retry() {
    if (!gameStarted) return;
    init();
  }

  retryBtn.onclick = retry;
  guessBtn.onclick = handleGuess;
  guessInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') handleGuess();
  });
};
</script>
</body>
</html>
