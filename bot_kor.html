<!DOCTYPE html>

<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì›Œí¼ì¦ˆë©”ì´íŠ¸</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f0f8f7;
      margin: 0;
      padding: 20px;
      color: #333;
      text-align: center;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 10px;
      font-weight: bold;
      color: #064d4d;
    }
    p {
      font-size: 14px;
      margin-bottom: 20px;
      color: #064d4d;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .player-input input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 150px;
      text-align: center;
    }
    .guess-section {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .guess-section input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #aaa;
      border-radius: 4px;
      width: 200px;
    }
    .game-area {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .game-button {
      font-size: 18px;
      background-color: #c8f4ee;
      padding: 10px 22px;
      margin: 8px;
      color: #064d4d;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .game-button:hover {
      background-color: #1d9e95;
      transform: scale(1.05);
    }
    .cell {
      width: 45px;
      height: 45px;
      background-color: #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      cursor: pointer;
      user-select: none;
      border: 1px solid #999;
    }
    .revealed { background-color: #fff; }
    .word-owned-player1 { background-color: #b7d5f2; }
    .word-owned-player2 { background-color: #f6c28b; }
    #player1Score, #player2Score {
      width: 160px;
      min-height: 300px;
      padding: 10px;
      font-size: 20px;
      font-weight: bold;
      border: 2px solid #333;
    }
    #player1Score { background-color:  #b7d5f2; }
    #player2Score { background-color: #f6c28b; }
    #currentTurn {
      font-size: 20px;
      margin: 10px;
      color: #056762;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(17, 45px);
      grid-gap: 3px;
      padding: 10px;
      border: 2px solid #333;
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
  </style>
</head>

<body>

<h1 id="game-title">ê²Œì„ ì œëª©</h1>
<p id="game-desc">ê²Œì„ ì„¤ëª…</p>

<div class="game-container">


  <div id="gameSection" class="hidden">
    <div id="currentTurn"></div>

<div class="guess-section">
  <input type="text" id="guessInput" placeholder="ì¶”ì¸¡í•œ ë‹¨ì–´" />
  <button id="guessBtn" class="game-button">ì œì¶œ</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>ì—†ëŠ” ë‹¨ì–´:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

<div class="controls">
  <button id="retryBtn" class="game-button">ë‹¤ì‹œ í•˜ê¸°</button>
  <button onclick="location.href='index.html'" class="game-button">ì´ˆê¸° í™”ë©´</button>
</div>

  </div>

</div>
<script>
window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    // ì„ì‹œë¡œ ê¸°ë³¸ ë‹¨ì–´ë“¤ ì„¤ì •
    words = ["ë¶ê·¹ì—¬ìš°","ê³ ì–‘ì´","ì„ ì¸ì¥","ì‚¬ë§‰ì—¬ìš°","ë‹¬íŒ½ì´","í—¤ë¼í´ë ˆìŠ¤","ì–‘í™”ëŒ€êµ"];
    gameSection.classList.remove('hidden');
    init();
    return;
  }

fetch(â€˜wordpools/â€™ + poolFile + â€˜.jsonâ€™)
.then(res => res.json())
.then(data => {
document.getElementById(â€˜game-titleâ€™).textContent = data.title || â€˜ê²Œì„ ì œëª©â€™;
const rawText = data.description || â€˜ê²Œì„ ì„¤ëª…â€™;
const htmlText = rawText.replace(/\n/g, â€˜<br>â€™);
document.getElementById(â€˜game-descâ€™).innerHTML = htmlText; // innerHTMLë¡œ ë³€ê²½


  words = [];
  for (let length in data.words) {
    const count = data.wordCount[length] || 0;
    words.push(...getRandomSample(data.words[length], count));
  }
  console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
  console.log('ë‹¨ì–´ ëª©ë¡:', words);
})
  startGame(); // ì—¬ê¸°ì—!
})

.catch(err => {
  document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message + '</p>';
});


const gridWidth = 17;
const gridHeight = 11;
const totalCells = gridWidth * gridHeight;
let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
let player1 = â€œí”Œë ˆì´ì–´1â€, player2 = â€œí”Œë ˆì´ì–´2â€, currentPlayerName = â€œâ€, wrongGuesses = [];

const gameEl = document.getElementById(â€˜gameâ€™);
const player1ScoreEl = document.getElementById(â€˜player1Scoreâ€™);
const player2ScoreEl = document.getElementById(â€˜player2Scoreâ€™);
const retryBtn = document.getElementById(â€˜retryBtnâ€™);
const startBtn = document.getElementById(â€˜startBtnâ€™);
const gameSection = document.getElementById(â€˜gameSectionâ€™);
const currentTurnEl = document.getElementById(â€˜currentTurnâ€™);
const guessInput = document.getElementById(â€˜guessInputâ€™);
const guessBtn = document.getElementById(â€˜guessBtnâ€™);
const wrongListEl = document.getElementById(â€˜wrongListâ€™);
const wrongGuessesEl = document.getElementById(â€˜wrongGuessesâ€™);

function shuffle(arr) {
for (let i = arr.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[arr[i], arr[j]] = [arr[j], arr[i]];
}
}

function getRandomSample(arr, count) {
if (count >= arr.length) return [â€¦arr];
const shuffled = [â€¦arr];
shuffle(shuffled);
return shuffled.slice(0, count);
}

function startGame() {
player1 = document.getElementById(â€˜player1Nameâ€™).value.trim() || â€œí”Œë ˆì´ì–´1â€;
player2 = document.getElementById(â€˜player2Nameâ€™).value.trim() || â€œí”Œë ˆì´ì–´2â€;


gameSection.classList.remove('hidden');

gameStarted = true;

init();


}

function init() {
board = Array(totalCells).fill(null);
revealed = Array(totalCells).fill(false);
wordMap = {};
foundWords = new Set();
foundBy = { player1: [], player2: [] };
currentPlayer = â€˜player1â€™;
usedIndexes = new Set();
clovers.clear();
daisies.clear();
wrongGuesses = [];
wrongListEl.textContent = â€œâ€;
wrongGuessesEl.style.display = â€˜noneâ€™;
resultShown = false;


gameEl.innerHTML = '';
for (let i = 0; i < totalCells; i++) {
  const cell = document.createElement('div');
  cell.className = 'cell';
  cell.onclick = () => { if (!resultShown) handleClick(i); };
  gameEl.appendChild(cell);
}

// ë°©í–¥ ê²€ì¦ê³¼ í•¨ê»˜ ë‹¨ì–´ ë°°ì¹˜
if (placeAllWordsWithVariety()) {
  console.log('ëª¨ë“  ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤ (3ë°©í–¥ ì‚¬ìš©)');
} else {
  console.log('ë°©í–¥ ê²€ì¦ ì‹¤íŒ¨ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
  // ê¸°ë³¸ ë°°ì¹˜ ë¡œì§
  let placedWords = [];
  shuffle(words);
  
  for (let word of words) {
    let placed = false;
    for (let attempt = 0; attempt < 500; attempt++) {
      if (placeWord(word)) {
        placedWords.push(word);
        placed = true;
        break;
      }
    }
    if (!placed) {
      console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
    }
  }
  console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
}

// í´ë¡œë²„/ë°ì´ì§€ ë°°ì¹˜ (ë‹¨ì–´ ì˜ì—­ í”¼í•˜ê¸°)
placeDaisies(12);
placeClovers(25);
fillEmptyCells();
updateScore();
updateTurnDisplay();

// ê²Œì„ ì¢…ë£Œ ì¡°ê±´ í™•ì¸
checkGameEnd();


}

function canPlaceWord(word, x, y, dx, dy) {
for (let i = 0; i < word.length; i++) {
let nx = x + dx * i, ny = y + dy * i;
if (nx < 0 || ny < 0 || nx >= gridWidth || ny >= gridHeight) return false;


  let idx = ny * gridWidth + nx;
  if (board[idx] && board[idx] !== word[i]) return false;
  if (usedIndexes.has(idx)) return false;
}
return true;


}

function placeWord(word) {
const directions = [
{ x: 1, y: 0 },   // ê°€ë¡œ (ì˜¤ë¥¸ìª½)
{ x: 0, y: 1 },   // ì„¸ë¡œ (ì•„ë˜)
{ x: 1, y: 1 },   // ëŒ€ê°ì„  (ì˜¤ë¥¸ìª½ ì•„ë˜)
];


// ë°©í–¥ì„ ë¬´ì‘ìœ„ë¡œ ì„ì–´ì„œ ë” ë‹¤ì–‘í•œ ë°°ì¹˜
const shuffledDirections = directions.sort(() => Math.random() - 0.5);


for (let dir of shuffledDirections) {


const startY = Math.floor(Math.random() * gridHeight);
for (let i = 0; i < gridHeight; i++) {
const y = (startY + i) % gridHeight;
for (let x = 0; x < gridWidth; x++) {
if (canPlaceWord(word, x, y, dir.x, dir.y)) {
let positions = [];
for (let i = 0; i < word.length; i++) {
let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridWidth + nx;
board[idx] = word[i];
usedIndexes.add(idx);
positions.push(idx);
}
wordMap[word] = {
positions: positions,
direction: [dir.x, dir.y] // ë°©í–¥ ì •ë³´ ì €ì¥
};
return true;
}
}
}
}
return false;
}

function checkDirectionVariety() {
let directionCount = {
â€˜1,0â€™: 0,    // ê°€ë¡œ
â€˜0,1â€™: 0,    // ì„¸ë¡œ
â€˜1,1â€™: 0     // ëŒ€ê°ì„ 
};


// wordMapì—ì„œ ê° ë‹¨ì–´ì˜ ë°©í–¥ ì²´í¬
for (let word in wordMap) {
  const direction = wordMap[word].direction;
  const key = direction[0] + ',' + direction[1];
  if (directionCount.hasOwnProperty(key)) {
    directionCount[key]++;
  }
}

console.log('ë°©í–¥ë³„ ì‚¬ìš© íšŸìˆ˜:', directionCount);

// 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ëëŠ”ì§€ í™•ì¸
return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;


}

function placeAllWordsWithVariety() {
let attempts = 0;
const maxAttempts = 10;


do {
  // ì´ˆê¸°í™”
  board = Array(totalCells).fill(null);
  usedIndexes.clear();
  wordMap = {};
  
  // ëª¨ë“  ë‹¨ì–´ ë°°ì¹˜ ì‹œë„
  let allPlaced = true;
  const shuffledWords = [...words].sort(() => Math.random() - 0.5);
  
  for (let word of shuffledWords) {
    if (!placeWord(word)) {
      allPlaced = false;
      break;
    }
  }
  
  if (allPlaced && checkDirectionVariety()) {
    console.log(`ì„±ê³µ! ${attempts + 1}ë²ˆì§¸ ì‹œë„ì—ì„œ 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ë¨`);
    return true; // ì„±ê³µ
  }
  
  attempts++;
  console.log(`${attempts}ë²ˆì§¸ ì‹œë„ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„`);
} while (attempts < maxAttempts);

console.log('ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
return false; // ì‹¤íŒ¨


}

function placeClovers(count) {
let placed = 0;
let attempts = 0;
while (placed < count && attempts < 1000) {
const idx = Math.floor(Math.random() * totalCells);
if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
// ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ëŠ”ì§€ í™•ì¸
if (isSafeForSpecial(idx)) {
clovers.add(idx);
placed++;
}
}
attempts++;
}
console.log(â€˜ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:â€™, clovers.size);
}

function placeDaisies(count) {
let placed = 0;
let attempts = 0;
while (placed < count && attempts < 1000) {
const idx = Math.floor(Math.random() * totalCells);
if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
// ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ëŠ”ì§€ í™•ì¸
if (isSafeForSpecial(idx)) {
daisies.add(idx);
placed++;
}
}
attempts++;
}
console.log(â€˜ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:â€™, daisies.size);
}

function isSafeForSpecial(idx) {
const x = idx % gridWidth;
const y = Math.floor(idx / gridWidth);

// ì£¼ë³€ 8ì¹¸ì— ë‹¤ë¥¸ ì•„ì´í…œì´ ìˆëŠ”ì§€ë§Œ í™•ì¸ (ë‹¨ì–´ëŠ” ìƒê´€ì—†ìŒ)
for (let dy = -1; dy <= 1; dy++) {
for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;
const nx = x + dx;
const ny = y + dy;
if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
const nIdx = ny * gridWidth + nx;
if (clovers.has(nIdx) || daisies.has(nIdx)) {
return false;
}
}
}
}
return true;
}

function fillEmptyCells() {
const filler = â€˜ê°™ê°›ê°œê±°ê±´ê±¸ê²ƒê²Œê³ ê´´êµêµ­ê¶ê·¸ê·¼ê¸ˆê¸°ê¸´ê¹Œê¹œê¹¨êº¾ê»´ê¼¼ê½ê¾¸ë”ë‚œë‚´ë„˜ë„£ë„¤ë†€ë†ˆëˆ„ë‰´ëŠ”ë‹ˆë‹˜ë‹¤ë‹¥ëŒ€ëŒ„ë”ë˜ë©ë°ë„ë™ë‘ë“œë“ë“ ë“£ë“¤ë“±ë””ë”œë”±ë•Œë•¡ë˜‘ëš«ë›°ë¼ë½ë€ëŒëë‘ë˜ëœëŸ¬ë ˆë ¤ë ¥ë ¸ë¡œë¡­ë¥´ë¥¸ë¥¼ë¦¬ë¦°ë¦¼ë§ˆë§Œë§›ë§ë§¨ë¨¸ë¨¼ë©€ë©”ë©˜ë©°ëª°ë¬´ë¬»ë­˜ë¯¸ë¯¼ë°”ë°›ë°©ë²„ë²…ë²ˆë´ë´¤ë¶€ë¶™ë¸Œë¸”ë¹„ë¹ˆë¹Œë¹”ë¹ ë¹¡ë¹¨ë¹¼ë»¥ì‚¬ìƒˆìƒì„œì„­ì„°ì„¸ìˆ™ì‰¬ìŠ´ì‹¤ì‹¶ìŒì“°ì”Œì”»ì•„ì•…ì•Œì•˜ì• ì•¼ì–´ì—„ì—…ì—†ì—ˆì—‰ì—ì—¬ì—´ì˜›ì˜¤ì˜¨ì˜¬ì™€ì™”ì™œìš°ìš¸ì›ìœ„ìœ ìœ¤ìœ¼ì„ìŒì˜ìµì¸ìƒìˆìŠì‘ì–ì˜ì €ì „ì œì ¸ì¢‹ì£¼ì¤¬ì§œì§ì°ì°¨ì°©ì°¸ì°½ì±„ì²™ì²œì²­ì²´ì³¤ì´ˆì¶œì·„ì·¨ì¹˜ì¹œì¹´ì¼œì½”ì½œí¬í…Œí† íŠ¸íŠ¼í­í•€í•˜í•™í•œí• í•´í–„í–ˆí–‰í˜„í˜¸í˜¼í™”í™˜íˆâ€™.split(â€™â€™);
shuffle(filler);
let i = 0;
for (let j = 0; j < totalCells; j++) {
if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
board[j] = filler[i++ % filler.length];
}
}
}

function reveal(index) {
if (revealed[index]) return;
revealed[index] = true;
const cell = gameEl.children[index];


if (clovers.has(index)) {
  cell.textContent = 'ğŸ€';
  // ìƒí•˜ì¢Œìš° 4ì¹¸ ì—´ê¸°
  const directions = [-gridWidth, gridWidth, -1, 1];
  for (let d of directions) {
    const newIdx = index + d;
    if (newIdx >= 0 && newIdx < totalCells) {
      // ì¢Œìš° ì´ë™ ì‹œ ê°™ì€ í–‰ì— ìˆëŠ”ì§€ í™•ì¸
      if (d === -1 || d === 1) {
        if (Math.floor(index / gridWidth) === Math.floor(newIdx / gridWidth)) {
          reveal(newIdx);
        }
      } else {
        reveal(newIdx);
      }
    }
  }
} else if (daisies.has(index)) {
  cell.textContent = 'ğŸŒ¼';
  // ì£¼ë³€ 8ì¹¸ ëª¨ë‘ ì—´ê¸°
  const x = index % gridWidth;
  const y = Math.floor(index / gridWidth);
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
        const nIdx = ny * gridWidth + nx;
        if (!revealed[nIdx]) reveal(nIdx);
      }
    }
  }
} else {
  cell.textContent = board[index];
}
cell.classList.add('revealed');


}

function updateScore() {
player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `âœ“ ${w}`).join(â€<br>â€);
player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `âœ“ ${w}`).join(â€<br>â€);
}

function updateTurnDisplay() {
if (!gameStarted) return;
currentPlayerName = currentPlayer === â€˜player1â€™ ? player1 : player2;
currentTurnEl.textContent = `${currentPlayerName}ë‹˜ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤`;
}

function switchTurn(extra) {
if (!extra) {
currentPlayer = currentPlayer === â€˜player1â€™ ? â€˜player2â€™ : â€˜player1â€™;
}
updateTurnDisplay();
}

function handleClick(index) {
if (revealed[index] || resultShown || !gameStarted) return;


const extra = clovers.has(index) || daisies.has(index);
reveal(index);
checkWords();
checkGameEnd();

if (!resultShown) {
  switchTurn(extra);
}


}

function checkWords() {
for (let word of Object.keys(wordMap)) {
if (foundWords.has(word)) continue;
const pos = wordMap[word].positions; // .positions ì¶”ê°€
if (pos.every(i => revealed[i])) {
foundWords.add(word);
foundBy[currentPlayer].push(word);
pos.forEach(i => {
const cell = gameEl.children[i];
cell.classList.add(currentPlayer === â€˜player1â€™ ? â€˜word-owned-player1â€™ : â€˜word-owned-player2â€™);
});
updateScore();
}
}
}

function checkGameEnd() {
const totalWords = Object.keys(wordMap).length;
if (foundWords.size >= totalWords && totalWords > 0) {
resultShown = true;


  setTimeout(() => {
    alert("ê²Œì„ ì¢…ë£Œ!");
  }, 500);
}


}

function handleGuess() {
if (!gameStarted) return;


const guess = guessInput.value.trim();
guessInput.value = "";
if (!guess || foundWords.has(guess)) return;

if (wordMap[guess]) {
  const pos = wordMap[guess].positions; // .positions ì¶”ê°€
  pos.forEach(i => {
    if (!revealed[i]) reveal(i);
  });
  foundWords.add(guess);
  foundBy[currentPlayer].push(guess);
  pos.forEach(i => {
    const cell = gameEl.children[i];
    cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
  });
  updateScore();
  checkGameEnd();
} else {
  if (!wrongGuesses.includes(guess)) {
    wrongGuesses.push(guess);
    wrongListEl.textContent = wrongGuesses.join(", ");
    wrongGuessesEl.style.display = 'block';
  }
}

if (!resultShown) {
  switchTurn(false);
}


}

function retry() {
if (!gameStarted) return;
init();
}

retryBtn.onclick = retry;
guessBtn.onclick = handleGuess;
guessInput.addEventListener(â€˜keypressâ€™, e => {
if (e.key === â€˜Enterâ€™) handleGuess();
});
};
</script>

</body>
</html>
