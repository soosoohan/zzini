<!DOCTYPE html>

<html lang="ko">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4YZHC1G9FN"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-4YZHC1G9FN');
  </script>
    <meta charset="UTF-8" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>ì›Œí¼ì¦ˆ ì°Œë‹ˆ - 2ì¸ìš© í° ê²©ì ë‹¨ì–´ ê²Œì„ | Soosooland</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="format-detection" content="telephone=no" />
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="ì¹œêµ¬ì™€ í° ê²©ìì—ì„œ ë‹¨ì–´ ëŒ€ê²°! 2ì¸ìš© ì›Œí¼ì¦ ê³ ê¸‰ ë²„ì „. ë§ì€ ë‹¨ì–´ì™€ ì „ëµì  í”Œë ˆì´ë¡œ ì–´íœ˜ë ¥ ê²¨ë£¨ê¸°.">
    <meta name="keywords" content="ì›Œí¼ì¦ˆì°Œë‹ˆ, 2ì¸ìš©ë‹¨ì–´ê²Œì„, í°ê²©ìê²Œì„, ì›Œí¼ì¦, ì¹œêµ¬ì™€ê²Œì„, ê³ ê¸‰ë‹¨ì–´ê²Œì„, ëŒ€ê²°ê²Œì„, ì–´íœ˜ë ¥ê²Œì„">
    <meta name="author" content="Soosooland">
    
    <!-- Open Graph -->
    <meta property="og:title" content="ì›Œí¼ì¦ˆ ì°Œë‹ˆ - 2ì¸ìš© í° ê²©ì ë‹¨ì–´ ê²Œì„">
    <meta property="og:description" content="ì¹œêµ¬ì™€ í° ê²©ìì—ì„œ ë‹¨ì–´ ëŒ€ê²°! 2ì¸ìš© ì›Œí¼ì¦ ê³ ê¸‰ ë²„ì „">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://soosooland.com/zzini/zzini_kor.html">
    <meta property="og:image" content="https://soosooland.com/images/worpuzz.jpeg">
    <meta property="og:site_name" content="Soosooland">
    <link rel="canonical" href="https://soosooland.com/zzini/zzini_kor.html">
    <link rel="alternate" hreflang="ko" href="https://soosooland.com/zzini/zzini_kor.html">
    <link rel="alternate" hreflang="en" href="https://soosooland.com/zzini/zzini_eng.html">
    <link rel="stylesheet" href="https://soosooland.com/css/protection.css">
    <script src="https://soosooland.com/js/protection.js"></script>
<style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }


html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  overflow-y: auto;
  position: relative;
  width: 100%;
  -webkit-overflow-scrolling: touch;
}

body {
  font-family: 'Noto Sans KR', sans-serif;
  background-color: #145454;
  color: #145454;
  text-align: center;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.screen-warning {
  display: none;
  text-align: center;
  padding: 40px;
  font-family: Arial, sans-serif;
  max-width: 400px;
  margin: 100px auto;
  background-color: #f8f9fa;
  border-radius: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.screen-warning h2 {
  color: #dc3545;
  margin-bottom: 20px;
}

.screen-warning p {
  color: #666;
  line-height: 1.6;
}
#game-title {
  display: inline;
  margin-right: 10px;
}
#game-desc {
  display: inline;
  font-size: 0.9em;
  color: #c3dbdb;
}
.back-button {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 8px 10px;      /* ëª¨ë°”ì¼ ê¸°ë³¸ */
    font-size: 1.5em;
    font-weight: bold;
    background-color: #CFF9FF;
    color: #0A6A79;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
}
.back-button:hover {
    background-color: #1baf8f;
    color: #fff;
}
h1 {
  font-size: clamp(18px, 4vw, 24px);
  font-weight: bold;
  color: #c3dbdb;
  margin: 5px;
}

p {
  font-size: clamp(14px, 3vw, 18px);
  color: #c8f4ee;
  margin: 5px;
}

.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  max-width: 100vw;
  overflow: hidden;
}

.player-input input {
  font-size: clamp(16px, 3vw, 18px);
  padding: 6px;
  border: 1px solid #ccc;
  border-radius: 4px;
  width: clamp(120px, 30vw, 150px);
  text-align: center;
}

.start-section {
  margin-bottom: 10px;
}

.guess-section {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
  flex-wrap: wrap;
  padding: 0 10px;
}

.guess-section input {
  font-size: clamp(16px, 3vw, 18px);
  padding: 6px;
  border: 1px solid #aaa;
  border-radius: 4px;
  width: clamp(150px, 40vw, 200px);
  min-width: 150px;
}

.game-area {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: clamp(8px, 2vw, 15px);
  margin-bottom: 10px;
  width: 100%;
  max-width: 100vw;
  overflow: hidden;
}

.game-button {
  font-size: clamp(14px, 3vw, 16px);
  background-color: #c8f4ee;
  padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 18px);
  margin: 4px;
  color: #064d4d;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  touch-action: manipulation;
  white-space: nowrap;
}

.game-button:hover, .game-button:active {
  background-color: #1d9e95;
  transform: scale(1.02);
}

.cell {
  width: 100%;
  height: 100%;
  background-color: #c3dbdb;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 1.5em;
  cursor: pointer;
  border: 1px solid #999;
  touch-action: manipulation;
}

.revealed { 
  background-color: #fff; 
  font-size: 1.5em;
}

.word-owned-player1 { 
  background-color: #b7d5f2; 
}

.word-owned-player2 { 
  background-color: #f6c28b; 
}

#player1Score, #player2Score {
  width: 180px;
  height: 560px;
  padding: 8px;
  font-size: 1.2em;
  font-weight: bold;
  border: 2px solid #333;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

#player1Score { 
  background-color: #b7d5f2; 
}

#player2Score { 
  background-color: #f6c28b; 
}

#currentTurn {
  font-size: clamp(14px, 3vw, 18px);
  margin: 8px;
  color: #c3dbdb;
  font-weight: bold;
}

/* ì°¾ì€ ë‹¨ì–´ ëª©ë¡ ì»¨í…Œì´ë„ˆ */
.found-words-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
}

.found-word {
  background-color: rgba(255, 255, 255, 0.3);
  padding: 4px 8px;
  border-radius: 4px;
  white-space: nowrap;
}

#game {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  grid-template-rows: repeat(12, 1fr);
  grid-gap: 4px;
  padding: 8px;
  border: 2px solid #333;
  background-color: #eee;
  width: 544px;
  height: 544px;
}

.hidden {
  display: none;
}

.controls {
  margin-top: 10px;
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
}

#wrongGuesses {
  font-size: clamp(12px, 2.5vw, 14px);
  margin: 5px 0;
  padding: 0 10px;
  word-wrap: break-word;
}

.inline { 
  display: inline; 
}


@media screen and (max-width: 1000px) {
  body {
    padding: 5px;
  }
  
  .game-area {
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  
  #player1Score, #player2Score {
    width: 544px;
    height: auto;
    min-height: 120px;
    max-height: 500px;  /* ìµœëŒ€ ë†’ì´ ì œí•œ */
    display: flex;
    flex-direction: column;
    order: 3;
  }
 /* ë‹¨ì–´ ì»¨í…Œì´ë„ˆê°€ flex-wrapìœ¼ë¡œ ì¤„ë°”ê¿ˆ */
  .found-words-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
  }
  
  #game {
    order: 1;
    margin-bottom: 10px;
  }
  
  #currentTurn {
    order: 2;
  } 
}
  </style>
</head>

<body>
  <div class="screen-warning" id="warning">
    <h2>Screen Too Small</h2>
    <p>This game is a mode where two users compete on a large grid, designed to be played on screens of at least 600px or larger.</p>
    <p>For screens smaller than 600px, please use Worpuzzmate.</p>
    <p>ì´ ê²Œì„ì€ ë‘ ì‚¬ìš©ìê°€ í° ê²©ìì—ì„œ ëŒ€ê²°í•˜ëŠ” ëª¨ë“œë¡œ ìµœì†Œ 600px ì´ìƒì˜ í™”ë©´ì—ì„œ í”Œë ˆì´í•˜ë„ë¡ ë””ìì¸ë˜ì—ˆìŠµë‹ˆë‹¤</p>
    <p>600px ë³´ë‹¤ ì‘ì€ í™”ë©´ì—ì„œëŠ” ì›Œí¼ì¦ˆë©”ì´íŠ¸ë¥¼ ì´ìš©í•˜ì„¸ìš”</p>
    <button onclick="location.href='https://soosooland.com/worpuzzmate/'" class="game-button">Play Worpuzzmate<br> ì›Œí¼ì¦ˆë©”ì´íŠ¸ í•˜ëŸ¬ê°€ê¸°</button>
  </div>
<button class="back-button"  onclick="location.href='index.html'">â†</button>
<div class="game-header"> 
  <h1 id="game-title">ê²Œì„ ì œëª©</h1>
  <p id="game-desc">ê²Œì„ ì„¤ëª…</p>
</div>
  <div class="game-container" id="game-container">
    <div id="gameSection" class="hidden">
      <div id="currentTurn"></div>
  <div class="guess-section">
    <input type="text" id="guessInput" placeholder="ì¶”ì¸¡í•œ ë‹¨ì–´ ì…ë ¥" />
    <button id="guessBtn" class="game-button">ì œì¶œ</button>
    <button id="retryBtn" class="game-button">â†» ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <div id="wrongGuesses" style="display: none;">
    <strong>ì˜ˆì¸¡ì´ í‹€ë¦° ë‹¨ì–´:</strong> <span id="wrongList"></span>
  </div>

  <div class="game-area">
    <div id="player1Score"></div>
    <div id="game"></div>
    <div id="player2Score"></div>
  </div>

</div>


  </div>

  <script>
    function checkScreenSize() {
      const warning = document.getElementById('warning');
      
      if (window.innerWidth < 600) {
        warning.style.display = 'block';
        document.getElementById('game-title').style.display = 'none';
        document.getElementById('game-desc').style.display = 'none';
        document.querySelector('.game-container').style.display = 'none';
      } else {
        warning.style.display = 'none';
        document.getElementById('game-title').style.display = 'inline';
        document.getElementById('game-desc').style.display = 'inline';
        document.querySelector('.game-container').style.display = 'flex';
      }
    }
    
    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);

    // Prevent zoom/scroll
    document.addEventListener('touchmove', function(e) {
      if (e.scale !== 1) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('gesturestart', function(e) {
      e.preventDefault();
    });

    document.addEventListener('gesturechange', function(e) {
      e.preventDefault();
    });

    document.addEventListener('gestureend', function(e) {
      e.preventDefault();
    });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
    const gridWidth = 12;
    const gridHeight = 12;
    const totalCells = gridWidth * gridHeight;
    let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
    let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
    let player1 = "Player 1", player2 = "Player 2", currentPlayerName = "", wrongGuesses = [];

    const gameEl = document.getElementById('game');
    const player1ScoreEl = document.getElementById('player1Score');
    const player2ScoreEl = document.getElementById('player2Score');
    const retryBtn = document.getElementById('retryBtn');
    const gameSection = document.getElementById('gameSection');
    const currentTurnEl = document.getElementById('currentTurn');
    const guessInput = document.getElementById('guessInput');
    const guessBtn = document.getElementById('guessBtn');
    const wrongListEl = document.getElementById('wrongList');
    const wrongGuessesEl = document.getElementById('wrongGuesses');

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function getRandomSample(arr, count) {
      if (count >= arr.length) return [...arr];
      const shuffled = [...arr];
      shuffle(shuffled);
      return shuffled.slice(0, count);
    }

    window.onload = () => {
      const urlParams = new URLSearchParams(window.location.search);
      const poolFile = urlParams.get('pool');
      
      if (!poolFile) {
          words = ['ê²Œì„ì„¤ëª…', 'ê³ ì–‘ì´', 'ì–‘í™”ëŒ€êµ', 'ë‹¨ì–´ëª©ë¡', 'í¼ì¦ê²Œì„', 'ì „ëµê²Œì„', 'ìˆ˜ìˆ˜ëœë“œ', 'ê°•ì•„ì§€'];
        gameSection.classList.remove('hidden');
        startGame();
        return;
      }

      fetch('wordpools/' + poolFile + '.json')
        .then(res => res.json())
        .then(data => {
          document.getElementById('game-title').textContent = data.title || 'ê²Œì„ ì œëª©';
          const rawText = data.description || 'ê²Œì„ ì„¤ëª…';
          const htmlText = rawText.replace(/\n/g, '<br>');
          document.getElementById('game-desc').innerHTML = htmlText;

          words = [];
          for (let length in data.words) {
            const count = data.wordCount[length] || 0;
            words.push(...getRandomSample(data.words[length], count));
          }
          console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
          console.log('ë‹¨ì–´ ëª©ë¡:', words);
          
          startGame();
        })
        .catch(err => {
          document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message + '</p>';
        });
    };

    function startGame() {
     player1 = "í”Œë ˆì´ì–´1";
     player2 = "í”Œë ˆì´ì–´2";
    gameSection.classList.remove('hidden');
    gameStarted = true;
    
    init();
  }

    function init() {
      board = Array(totalCells).fill(null);
      revealed = Array(totalCells).fill(false);
      wordMap = {};
      foundWords = new Set();
      foundBy = { player1: [], player2: [] };
      currentPlayer = 'player1';
      usedIndexes = new Set();
      clovers.clear();
      daisies.clear();
      wrongGuesses = [];
      wrongListEl.textContent = "";
      wrongGuessesEl.style.display = 'none';
      resultShown = false;

      gameEl.innerHTML = '';
      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.onclick = () => { if (!resultShown) handleClick(i); };
        gameEl.appendChild(cell);
      }

      if (placeAllWordsWithVariety()) {
        console.log('ëª¨ë“  ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤ (3ë°©í–¥ ì‚¬ìš©)');
      } else {
        console.log('ë°©í–¥ ê²€ì¦ ì‹¤íŒ¨ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
        let placedWords = [];
        shuffle(words);
        
        for (let word of words) {
          let placed = false;
          for (let attempt = 0; attempt < 500; attempt++) {
            if (placeWord(word)) {
              placedWords.push(word);
              placed = true;
              break;
            }
          }
          if (!placed) {
            console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
          }
        }
        console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
      }
      
      placeDaisies(23);
      placeClovers(15);
      fillEmptyCells();
      updateScore();
      updateTurnDisplay();
      checkGameEnd();
    }

    function canPlaceWord(word, x, y, dx, dy) {
      for (let i = 0; i < word.length; i++) {
        let nx = x + dx * i, ny = y + dy * i;
        if (nx < 0 || ny < 0 || nx >= gridWidth || ny >= gridHeight) return false;
        
        let idx = ny * gridWidth + nx;
        if (board[idx] && board[idx] !== word[i]) return false;
        if (usedIndexes.has(idx)) return false;
      }
      return true;
    }

    function placeWord(word) {
      const directions = [
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
      ];
      
      const shuffledDirections = directions.sort(() => Math.random() - 0.5);
     
      for (let dir of shuffledDirections) {
        const startY = Math.floor(Math.random() * gridHeight);
        for (let i = 0; i < gridHeight; i++) {
          const y = (startY + i) % gridHeight;
          for (let x = 0; x < gridWidth; x++) {
            if (canPlaceWord(word, x, y, dir.x, dir.y)) {
              let positions = [];
              for (let i = 0; i < word.length; i++) {
                let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridWidth + nx;
                board[idx] = word[i];
                usedIndexes.add(idx);
                positions.push(idx);
              }
              wordMap[word] = {
                positions: positions,
                direction: [dir.x, dir.y]
              };
              return true;
            }
          }
        }
      }
      return false;
    }

    function checkDirectionVariety() {
      let directionCount = {
        '1,0': 0,
        '0,1': 0,
        '1,1': 0
      };
      
      for (let word in wordMap) {
        const direction = wordMap[word].direction;
        const key = direction[0] + ',' + direction[1];
        if (directionCount.hasOwnProperty(key)) {
          directionCount[key]++;
        }
      }
      
      console.log('ë°©í–¥ë³„ ì‚¬ìš© íšŸìˆ˜:', directionCount);
      return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
    }

    function placeAllWordsWithVariety() {
      let attempts = 0;
      const maxAttempts = 10;
      
      do {
        board = Array(totalCells).fill(null);
        usedIndexes.clear();
        wordMap = {};
        
        let allPlaced = true;
        const shuffledWords = [...words].sort(() => Math.random() - 0.5);
        
        for (let word of shuffledWords) {
          if (!placeWord(word)) {
            allPlaced = false;
            break;
          }
        }
        
        if (allPlaced && checkDirectionVariety()) {
          console.log(`ì„±ê³µ! ${attempts + 1}ë²ˆì§¸ ì‹œë„ì—ì„œ 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ë¨`);
          return true;
        }
        
        attempts++;
        console.log(`${attempts}ë²ˆì§¸ ì‹œë„ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„`);
      } while (attempts < maxAttempts);
      
      console.log('ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
      return false;
    }

    function placeClovers(count) {
      let placed = 0;
      let attempts = 0;
      while (placed < count && attempts < 1000) {
        const idx = Math.floor(Math.random() * totalCells);
        if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
          if (isSafeForSpecial(idx)) {
            clovers.add(idx);
            placed++;
          }
        }
        attempts++;
      }
      console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
    }

    function placeDaisies(count) {
      let placed = 0;
      let attempts = 0;
      while (placed < count && attempts < 1000) {
        const idx = Math.floor(Math.random() * totalCells);
        if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
          if (isSafeForSpecial(idx)) {
            daisies.add(idx);
            placed++;
          }
        }
        attempts++;
      }
      console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
    }

    function isSafeForSpecial(idx) {
      const x = idx % gridWidth;
      const y = Math.floor(idx / gridWidth);
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
            const nIdx = ny * gridWidth + nx;
            if (clovers.has(nIdx) || daisies.has(nIdx)) {
              return false;
            }
          }
        }
      }
      return true;
    }

 function fillEmptyCells() {
    const filler = 'ê°™ê°›ê°œê±°ê±´ê±¸ê²ƒê²Œê³ ê´´êµêµ­ê¶ê·¸ê·¼ê¸ˆê¸°ê¸´ê¹Œê¹œê¹¨êº¾ê»´ê¼¼ê½ê¾¸ë”ë‚œë‚´ë„˜ë„£ë„¤ë†€ë†ˆëˆ„ë‰´ëŠ”ë‹ˆë‹˜ë‹¤ë‹¥ëŒ€ëŒ„ë”ë˜ë©ë°ë„ë™ë‘ë“œë“ë“ ë“£ë“¤ë“±ë””ë”œë”±ë•Œë•¡ë˜‘ëš«ë›°ë¼ë½ë€ëŒëë‘ë˜ëœëŸ¬ë ˆë ¤ë ¥ë ¸ë¡œë¡­ë¥´ë¥¸ë¥¼ë¦¬ë¦°ë¦¼ë§ˆë§Œë§›ë§ë§¨ë¨¸ë¨¼ë©€ë©”ë©˜ë©°ëª°ë¬´ë¬»ë­˜ë¯¸ë¯¼ë°”ë°›ë°©ë²„ë²…ë²ˆë´ë´¤ë¶€ë¶™ë¸Œë¸”ë¹„ë¹ˆë¹Œë¹”ë¹ ë¹¡ë¹¨ë¹¼ë»¥ì‚¬ìƒˆìƒì„œì„­ì„°ì„¸ìˆ™ì‰¬ìŠ´ì‹¤ì‹¶ìŒì“°ì”Œì”»ì•„ì•…ì•Œì•˜ì• ì•¼ì–´ì—„ì—…ì—†ì—ˆì—‰ì—ì—¬ì—´ì˜›ì˜¤ì˜¨ì˜¬ì™€ì™”ì™œìš°ìš¸ì›ìœ„ìœ ìœ¤ìœ¼ì„ìŒì˜ìµì¸ìƒìˆìŠì‘ì–ì˜ì €ì „ì œì ¸ì¢‹ì£¼ì¤¬ì§œì§ì°ì°¨ì°©ì°¸ì°½ì±„ì²™ì²œì²­ì²´ì³¤ì´ˆì¶œì·„ì·¨ì¹˜ì¹œì¹´ì¼œì½”ì½œí¬í…Œí† íŠ¸íŠ¼í­í•€í•˜í•™í•œí• í•´í–„í–ˆí–‰í˜„í˜¸í˜¼í™”í™˜íˆ'.split('');
    shuffle(filler);
    let i = 0;
    for (let j = 0; j < totalCells; j++) {
      if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
        board[j] = filler[i++ % filler.length];
      }
    }
  }

    function reveal(index) {
      if (revealed[index]) return;
      revealed[index] = true;
      const cell = gameEl.children[index];
      
      if (clovers.has(index)) {
        cell.textContent = 'ğŸ€';
        const directions = [-gridWidth, gridWidth, -1, 1];
        for (let d of directions) {
          const newIdx = index + d;
          if (newIdx >= 0 && newIdx < totalCells) {
            if (d === -1 || d === 1) {
              if (Math.floor(index / gridWidth) === Math.floor(newIdx / gridWidth)) {
                reveal(newIdx);
              }
            } else {
              reveal(newIdx);
            }
          }
        }    
      } else if (daisies.has(index)) {
  const img = document.createElement('img');
  img.src = 'daisy_64x64.png';
  img.alt = 'ë°ì´ì§€';
  img.style.width = '29px';
  img.style.height = '29px';
  cell.appendChild(img);
  
  const x = index % gridWidth;
  const y = Math.floor(index / gridWidth);
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
        const nIdx = ny * gridWidth + nx;
        if (!revealed[nIdx]) reveal(nIdx);
      }
    }
  }
} else {
        cell.textContent = board[index];
      }
      cell.classList.add('revealed');
    }

function updateScore() {
  const createWordsList = (words) => {
    if (words.length === 0) return '';
    return '<div class="found-words-container">' + 
           words.map(w => `<span class="found-word">${w}</span>`).join('') + 
           '</div>';
  };
  
  player1ScoreEl.innerHTML = `<strong>${player1}</strong>` + createWordsList(foundBy.player1);
  player2ScoreEl.innerHTML = `<strong>${player2}</strong>` + createWordsList(foundBy.player2);
}

    function updateTurnDisplay() {
      if (!gameStarted) return;
      currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
      currentTurnEl.textContent = `${currentPlayerName}ë‹˜ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.`;
    }

    function switchTurn(extra) {
      if (!extra) {
        currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
      }
      updateTurnDisplay();
    }

    function handleClick(index) {
      if (revealed[index] || resultShown || !gameStarted) return;
      
      const extra = clovers.has(index) || daisies.has(index);
      reveal(index);
      checkWords();
      checkGameEnd();
      
      if (!resultShown) {
        switchTurn(extra);
      }
    }

    function checkWords() {
      for (let word of Object.keys(wordMap)) {
        if (foundWords.has(word)) continue;
        const pos = wordMap[word].positions;
        if (pos.every(i => revealed[i])) {
          foundWords.add(word);
          foundBy[currentPlayer].push(word);
          pos.forEach(i => {
            const cell = gameEl.children[i];
            cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
          });
          updateScore();
        }
      }
    }

    function checkGameEnd() {
      const totalWords = Object.keys(wordMap).length;
      if (foundWords.size >= totalWords && totalWords > 0) {
        resultShown = true;
        
setTimeout(() => {
  const p1Count = foundBy.player1.length;
  const p2Count = foundBy.player2.length;
  let message = `ê²Œì„ ì¢…ë£Œ!\n\n${player1}: ${p1Count}ê°œ\n${player2}: ${p2Count}ê°œ\n\n`;
  
  if (p1Count > p2Count) {
    message += `${player1} ìŠ¹ë¦¬! ğŸ‰`;
  } else if (p2Count > p1Count) {
    message += `${player2} ìŠ¹ë¦¬! ğŸ‰`;
  } else {
    message += `ë¬´ìŠ¹ë¶€!`;
  }          
          alert(message);
        }, 500);
      }
    } 

    function handleGuess() {
      if (!gameStarted) return;
      
      const guess = guessInput.value.trim().toUpperCase();
      guessInput.value = "";
      if (!guess || foundWords.has(guess)) return;
      
      if (wordMap[guess]) {
        const pos = wordMap[guess].positions;
        pos.forEach(i => {
          if (!revealed[i]) reveal(i);
        });
        foundWords.add(guess);
        foundBy[currentPlayer].push(guess);
        pos.forEach(i => {
          const cell = gameEl.children[i];
          cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
        });
        updateScore();
        checkGameEnd();
      } else {
        if (!wrongGuesses.includes(guess)) {
          wrongGuesses.push(guess);
          wrongListEl.textContent = wrongGuesses.join(", ");
          wrongGuessesEl.style.display = 'block';
        }
      }
      
      if (!resultShown) {
        switchTurn(false);
      }
    }

    function retry() {
      if (!gameStarted) return;
      init();
    }

    retryBtn.onclick = retry;
    guessBtn.onclick = handleGuess;
    guessInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') handleGuess();
    });
  </script>

</body>
</html>
