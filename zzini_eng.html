<!DOCTYPE html>

<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4YZHC1G9FN"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-4YZHC1G9FN');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="format-detection" content="telephone=no" />
  <title>워퍼즈찌니영어</title>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }


html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow-x: hidden;
  position: fixed;
  width: 100%;
  -webkit-overflow-scrolling: touch;
}

body {
  font-family: 'Noto Sans KR', sans-serif;
  background-color: #f0f8f7;
  color: #333;
  text-align: center;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.screen-warning {
  display: none;
  text-align: center;
  padding: 40px;
  font-family: Arial, sans-serif;
  max-width: 400px;
  margin: 100px auto;
  background-color: #f8f9fa;
  border-radius: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.screen-warning h2 {
  color: #dc3545;
  margin-bottom: 20px;
}

.screen-warning p {
  color: #666;
  line-height: 1.6;
}

h1 {
  font-size: clamp(18px, 4vw, 24px);
  font-weight: bold;
  color: #064d4d;
  margin: 5px;
}

p {
  font-size: clamp(14px, 3vw, 18px);
  color: #064d4d;
  margin: 5px;
}

.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  max-width: 100vw;
  overflow: hidden;
}

.player-input input {
  font-size: clamp(16px, 3vw, 18px);
  padding: 6px;
  border: 1px solid #ccc;
  border-radius: 4px;
  width: clamp(120px, 30vw, 150px);
  text-align: center;
}

.start-section {
  margin-bottom: 10px;
}

.guess-section {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
  flex-wrap: wrap;
  padding: 0 10px;
}

.guess-section input {
  font-size: clamp(16px, 3vw, 18px);
  padding: 6px;
  border: 1px solid #aaa;
  border-radius: 4px;
  width: clamp(150px, 40vw, 200px);
  min-width: 150px;
}

.game-area {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: clamp(8px, 2vw, 15px);
  margin-bottom: 10px;
  width: 100%;
  max-width: 100vw;
  overflow: hidden;
}

.game-button {
  font-size: clamp(14px, 3vw, 16px);
  background-color: #c8f4ee;
  padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 18px);
  margin: 4px;
  color: #064d4d;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  touch-action: manipulation;
  white-space: nowrap;
}

.game-button:hover, .game-button:active {
  background-color: #1d9e95;
  transform: scale(1.02);
}

.cell {
  width: 100%;
  height: 100%;
  background-color: #ddd;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 1.5em;
  cursor: pointer;
  border: 1px solid #999;
  touch-action: manipulation;
}

.revealed { 
  background-color: #fff; 
  font-size: 1.5em;
}

.word-owned-player1 { 
  background-color: #b7d5f2; 
}

.word-owned-player2 { 
  background-color: #f6c28b; 
}

#player1Score, #player2Score {
  width: 180px;
  height: 480px;
  padding: 8px;
  font-size: 1.2em;
  font-weight: bold;
  border: 2px solid #333;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

#player1Score { 
  background-color: #b7d5f2; 
}

#player2Score { 
  background-color: #f6c28b; 
}

#currentTurn {
  font-size: clamp(14px, 3vw, 18px);
  margin: 8px;
  color: #056762;
  font-weight: bold;
}

#game {
  display: grid;
  grid-template-columns: repeat(19, 1fr);
  grid-template-rows: repeat(12, 1fr);
  grid-gap: 4px;
  padding: 8px;
  border: 2px solid #333;
  background-color: #eee;
  width: 757px;
  height: 480px;
}

.hidden {
  display: none;
}

.controls {
  margin-top: 10px;
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
}

#wrongGuesses {
  font-size: clamp(12px, 2.5vw, 14px);
  margin: 5px 0;
  padding: 0 10px;
  word-wrap: break-word;
}

.inline { 
  display: inline; 
}

@media screen and (max-width: 1200px) {
  body {
    padding: 5px;
  }
  
  .game-area {
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }
  
  #player1Score, #player2Score {
    width: 100%;
    max-width: 757px;
    height: auto;
    min-height: 100px;
    display: flex;
    flex-direction: column;
    order: 3;
  }
  
  #game {
    order: 1;
    margin-bottom: 10px;
  }
  
  #currentTurn {
    order: 2;
  } 
}


  </style>
</head>

<body>
  <div class="screen-warning" id="warning">
    <h2>Screen Too Small</h2>
    <p>This game is a mode where two users compete on a large grid, designed to be played on screens of at least 800px or larger.</p>
    <p>For screens smaller than 800px, please use Worpuzzmate.</p>
    <p>이 게임은 두 사용자가 큰 격자에서 대결하는 모드로 최소 800px 이상의 화면에서 플레이하도록 디자인되었습니다</p>
    <p>800px 보다 작은 화면에서는 워퍼즈메이트를 이용하세요</p>
    <button onclick="location.href='https://worpuzzmate.vercel.app'" class="game-button">Play Worpuzzmate<br> 워퍼즈메이트 하러가기</button>
  </div>

  <h1 id="game-title">게임 제목</h1>
  <p id="game-desc">게임 설명</p>

  <div class="game-container" id="game-container">
    <div id="gameSection" class="hidden">
      <div id="currentTurn"></div>


  <div class="guess-section">
    <input type="text" id="guessInput" placeholder="YOUR GUESS(UPPERCASE)" />
    <button id="guessBtn" class="game-button">SUBMIT</button>
  </div>

  <div id="wrongGuesses" style="display: none;">
    <strong>Invalid words:</strong> <span id="wrongList"></span>
  </div>

  <div class="game-area">
    <div id="player1Score"></div>
    <div id="game"></div>
    <div id="player2Score"></div>
  </div>

  <div class="controls">
    <button id="retryBtn" class="game-button">RETRY</button>
    <button onclick="location.href='index.html'" class="game-button">HOME</button>
  </div>
</div>


  </div>

  <script>
    function checkScreenSize() {
      const warning = document.getElementById('warning');
      
      if (window.innerWidth < 800) {
        warning.style.display = 'block';
        document.getElementById('game-title').style.display = 'none';
        document.getElementById('game-desc').style.display = 'none';
        document.querySelector('.game-container').style.display = 'none';
      } else {
        warning.style.display = 'none';
        document.getElementById('game-title').style.display = 'inline';
        document.getElementById('game-desc').style.display = 'inline';
        document.querySelector('.game-container').style.display = 'flex';
      }
    }
    
    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);

    // Prevent zoom/scroll
    document.addEventListener('touchmove', function(e) {
      if (e.scale !== 1) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('gesturestart', function(e) {
      e.preventDefault();
    });

    document.addEventListener('gesturechange', function(e) {
      e.preventDefault();
    });

    document.addEventListener('gestureend', function(e) {
      e.preventDefault();
    });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // 전역 변수 선언
    const gridWidth = 19;
    const gridHeight = 12;
    const totalCells = gridWidth * gridHeight;
    let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
    let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
    let player1 = "Player 1", player2 = "Player 2", currentPlayerName = "", wrongGuesses = [];

    const gameEl = document.getElementById('game');
    const player1ScoreEl = document.getElementById('player1Score');
    const player2ScoreEl = document.getElementById('player2Score');
    const retryBtn = document.getElementById('retryBtn');
    const gameSection = document.getElementById('gameSection');
    const currentTurnEl = document.getElementById('currentTurn');
    const guessInput = document.getElementById('guessInput');
    const guessBtn = document.getElementById('guessBtn');
    const wrongListEl = document.getElementById('wrongList');
    const wrongGuessesEl = document.getElementById('wrongGuesses');

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function getRandomSample(arr, count) {
      if (count >= arr.length) return [...arr];
      const shuffled = [...arr];
      shuffle(shuffled);
      return shuffled.slice(0, count);
    }

    window.onload = () => {
      const urlParams = new URLSearchParams(window.location.search);
      const poolFile = urlParams.get('pool');
      
      if (!poolFile) {
        words = ['CAT', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'CLICK', 'DOG'];
        gameSection.classList.remove('hidden');
        startGame();
        return;
      }

      fetch('wordpools/' + poolFile + '.json')
        .then(res => res.json())
        .then(data => {
          document.getElementById('game-title').textContent = data.title || '게임 제목';
          const rawText = data.description || '게임 설명';
          const htmlText = rawText.replace(/\n/g, '<br>');
          document.getElementById('game-desc').innerHTML = htmlText;

          words = [];
          for (let length in data.words) {
            const count = data.wordCount[length] || 0;
            words.push(...getRandomSample(data.words[length], count));
          }
          console.log('총 단어 수:', words.length);
          console.log('단어 목록:', words);
          
          startGame();
        })
        .catch(err => {
          document.body.innerHTML = '<p>❌ 워드풀 로딩 중 오류 발생: ' + err.message + '</p>';
        });
    };

    function startGame() {
      gameSection.classList.remove('hidden');
      gameStarted = true;
      init();
    }

    function init() {
      board = Array(totalCells).fill(null);
      revealed = Array(totalCells).fill(false);
      wordMap = {};
      foundWords = new Set();
      foundBy = { player1: [], player2: [] };
      currentPlayer = 'player1';
      usedIndexes = new Set();
      clovers.clear();
      daisies.clear();
      wrongGuesses = [];
      wrongListEl.textContent = "";
      wrongGuessesEl.style.display = 'none';
      resultShown = false;

      gameEl.innerHTML = '';
      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.onclick = () => { if (!resultShown) handleClick(i); };
        gameEl.appendChild(cell);
      }

      if (placeAllWordsWithVariety()) {
        console.log('모든 단어가 성공적으로 배치되었습니다 (3방향 사용)');
      } else {
        console.log('방향 검증 실패 - 기본 배치로 진행');
        let placedWords = [];
        shuffle(words);
        
        for (let word of words) {
          let placed = false;
          for (let attempt = 0; attempt < 500; attempt++) {
            if (placeWord(word)) {
              placedWords.push(word);
              placed = true;
              break;
            }
          }
          if (!placed) {
            console.log('배치 실패한 단어:', word);
          }
        }
        console.log('실제 배치된 단어 수:', placedWords.length);
      }
      
      placeDaisies(15);
      placeClovers(30);
      fillEmptyCells();
      updateScore();
      updateTurnDisplay();
      checkGameEnd();
    }

    function canPlaceWord(word, x, y, dx, dy) {
      for (let i = 0; i < word.length; i++) {
        let nx = x + dx * i, ny = y + dy * i;
        if (nx < 0 || ny < 0 || nx >= gridWidth || ny >= gridHeight) return false;
        
        let idx = ny * gridWidth + nx;
        if (board[idx] && board[idx] !== word[i]) return false;
        if (usedIndexes.has(idx)) return false;
      }
      return true;
    }

    function placeWord(word) {
      const directions = [
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
      ];
      
      const shuffledDirections = directions.sort(() => Math.random() - 0.5);
     
      for (let dir of shuffledDirections) {
        const startY = Math.floor(Math.random() * gridHeight);
        for (let i = 0; i < gridHeight; i++) {
          const y = (startY + i) % gridHeight;
          for (let x = 0; x < gridWidth; x++) {
            if (canPlaceWord(word, x, y, dir.x, dir.y)) {
              let positions = [];
              for (let i = 0; i < word.length; i++) {
                let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridWidth + nx;
                board[idx] = word[i];
                usedIndexes.add(idx);
                positions.push(idx);
              }
              wordMap[word] = {
                positions: positions,
                direction: [dir.x, dir.y]
              };
              return true;
            }
          }
        }
      }
      return false;
    }

    function checkDirectionVariety() {
      let directionCount = {
        '1,0': 0,
        '0,1': 0,
        '1,1': 0
      };
      
      for (let word in wordMap) {
        const direction = wordMap[word].direction;
        const key = direction[0] + ',' + direction[1];
        if (directionCount.hasOwnProperty(key)) {
          directionCount[key]++;
        }
      }
      
      console.log('방향별 사용 횟수:', directionCount);
      return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
    }

    function placeAllWordsWithVariety() {
      let attempts = 0;
      const maxAttempts = 10;
      
      do {
        board = Array(totalCells).fill(null);
        usedIndexes.clear();
        wordMap = {};
        
        let allPlaced = true;
        const shuffledWords = [...words].sort(() => Math.random() - 0.5);
        
        for (let word of shuffledWords) {
          if (!placeWord(word)) {
            allPlaced = false;
            break;
          }
        }
        
        if (allPlaced && checkDirectionVariety()) {
          console.log(`성공! ${attempts + 1}번째 시도에서 3방향 모두 사용됨`);
          return true;
        }
        
        attempts++;
        console.log(`${attempts}번째 시도 실패 - 다시 시도`);
      } while (attempts < maxAttempts);
      
      console.log('최대 시도 횟수 초과 - 기본 배치로 진행');
      return false;
    }

    function placeClovers(count) {
      let placed = 0;
      let attempts = 0;
      while (placed < count && attempts < 1000) {
        const idx = Math.floor(Math.random() * totalCells);
        if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
          if (isSafeForSpecial(idx)) {
            clovers.add(idx);
            placed++;
          }
        }
        attempts++;
      }
      console.log('배치된 클로버 수:', clovers.size);
    }

    function placeDaisies(count) {
      let placed = 0;
      let attempts = 0;
      while (placed < count && attempts < 1000) {
        const idx = Math.floor(Math.random() * totalCells);
        if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
          if (isSafeForSpecial(idx)) {
            daisies.add(idx);
            placed++;
          }
        }
        attempts++;
      }
      console.log('배치된 데이지 수:', daisies.size);
    }

    function isSafeForSpecial(idx) {
      const x = idx % gridWidth;
      const y = Math.floor(idx / gridWidth);
      
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
            const nIdx = ny * gridWidth + nx;
            if (clovers.has(nIdx) || daisies.has(nIdx)) {
              return false;
            }
          }
        }
      }
      return true;
    }

    function fillEmptyCells() {
      const filler = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      shuffle(filler);
      let i = 0;
      for (let j = 0; j < totalCells; j++) {
        if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
          board[j] = filler[i++ % filler.length];
        }
      }
    }

    function reveal(index) {
      if (revealed[index]) return;
      revealed[index] = true;
      const cell = gameEl.children[index];
      
      if (clovers.has(index)) {
        cell.textContent = '🍀';
        const directions = [-gridWidth, gridWidth, -1, 1];
        for (let d of directions) {
          const newIdx = index + d;
          if (newIdx >= 0 && newIdx < totalCells) {
            if (d === -1 || d === 1) {
              if (Math.floor(index / gridWidth) === Math.floor(newIdx / gridWidth)) {
                reveal(newIdx);
              }
            } else {
              reveal(newIdx);
            }
          }
        }
      } else if (daisies.has(index)) {
        cell.textContent = '🌼';
        const x = index % gridWidth;
        const y = Math.floor(index / gridWidth);
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
              const nIdx = ny * gridWidth + nx;
              if (!revealed[nIdx]) reveal(nIdx);
            }
          }
        }
      } else {
        cell.textContent = board[index];
      }
      cell.classList.add('revealed');
    }

    function updateScore() {
      player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `✓ ${w}`).join("<br>");
      player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `✓ ${w}`).join("<br>");
    }

    function updateTurnDisplay() {
      if (!gameStarted) return;
      currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
      currentTurnEl.textContent = `It is ${currentPlayerName}'s turn.`;
    }

    function switchTurn(extra) {
      if (!extra) {
        currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
      }
      updateTurnDisplay();
    }

    function handleClick(index) {
      if (revealed[index] || resultShown || !gameStarted) return;
      
      const extra = clovers.has(index) || daisies.has(index);
      reveal(index);
      checkWords();
      checkGameEnd();
      
      if (!resultShown) {
        switchTurn(extra);
      }
    }

    function checkWords() {
      for (let word of Object.keys(wordMap)) {
        if (foundWords.has(word)) continue;
        const pos = wordMap[word].positions;
        if (pos.every(i => revealed[i])) {
          foundWords.add(word);
          foundBy[currentPlayer].push(word);
          pos.forEach(i => {
            const cell = gameEl.children[i];
            cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
          });
          updateScore();
        }
      }
    }

    function checkGameEnd() {
      const totalWords = Object.keys(wordMap).length;
      if (foundWords.size >= totalWords && totalWords > 0) {
        resultShown = true;
        
        setTimeout(() => {
          const p1Count = foundBy.player1.length;
          const p2Count = foundBy.player2.length;
          let message = `Game Over!\n\n${player1}: ${p1Count} words\n${player2}: ${p2Count} words\n\n`;
          
          if (p1Count > p2Count) {
            message += `${player1} wins! 🎉`;
          } else if (p2Count > p1Count) {
            message += `${player2} wins! 🎉`;
          } else {
            message += `It's a tie! 🤝`;
          }
          
          alert(message);
        }, 500);
      }
    } 

    function handleGuess() {
      if (!gameStarted) return;
      
      const guess = guessInput.value.trim().toUpperCase();
      guessInput.value = "";
      if (!guess || foundWords.has(guess)) return;
      
      if (wordMap[guess]) {
        const pos = wordMap[guess].positions;
        pos.forEach(i => {
          if (!revealed[i]) reveal(i);
        });
        foundWords.add(guess);
        foundBy[currentPlayer].push(guess);
        pos.forEach(i => {
          const cell = gameEl.children[i];
          cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
        });
        updateScore();
        checkGameEnd();
      } else {
        if (!wrongGuesses.includes(guess)) {
          wrongGuesses.push(guess);
          wrongListEl.textContent = wrongGuesses.join(", ");
          wrongGuessesEl.style.display = 'block';
        }
      }
      
      if (!resultShown) {
        switchTurn(false);
      }
    }

    function retry() {
      if (!gameStarted) return;
      init();
    }

    retryBtn.onclick = retry;
    guessBtn.onclick = handleGuess;
    guessInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') handleGuess();
    });
  </script>

</body>
</html>
