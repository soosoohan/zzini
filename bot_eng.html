<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WORPUZZMONG</title>

<style>
  body {
    font-family: 'Noto Sans KR', sans-serif;
    background-color: #FFF2EB; /* ì „ì²´ ë°°ê²½: í”¼ì¹˜ í¬ë¦¼í†¤ */
    margin: 0;
    padding: 20px;
    color: #7A2E2E; /* ë”°ëœ»í•œ ë¸Œë¼ìš´ */
    text-align: center;
  }

  h1 {
    font-size: 28px;
    margin-bottom: 10px;
    font-weight: bold;
    color: #FF9494; /* í¬ì¸íŠ¸ í•‘í¬ */
  }

  p {
    font-size: 14px;
    margin-bottom: 20px;
    color: #A65A5A; /* ë¶€ë“œëŸ¬ìš´ ë¸Œë¼ìš´ */
  }

  .game-button {
    font-size: 18px;
    background-color: #FFD6BA; /* ì‚´êµ¬ë¹› ë²„íŠ¼ */
    padding: 10px 22px;
    margin: 8px;
    color: #7A2E2E;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }

  .game-button:hover {
    background-color: #FF9494;
    color: white;
    transform: scale(1.05);
  }

  .score-display {
    font-size: 20px;
    font-weight: bold;
    color: #7A2E2E;
    margin: 20px 0;
  }
  .score-computer {
    background-color: #CDFFD1; /* ì»´í“¨í„° ì ìˆ˜: ì—°ë‘ìƒ‰ ë°°ê²½ */
    padding: 5px 10px;
    border-radius: 4px;
    display: inline-block;
    margin: 0 5px;
  }

.score-computer, .score-user {
    display: inline-block;
    margin: 0 20px;
}

  .score-user {
    background-color: #FFDCDC; /* ì‚¬ìš©ì ì ìˆ˜: ì—°í•‘í¬ ë°°ê²½ */
    padding: 5px 10px;
    border-radius: 4px;
    display: inline-block;
    margin: 0 5px;
  }

  .cell {
    width: 38px;
    height: 38px;
    background-color: #FFFFFF;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 20px;
    cursor: pointer;
    user-select: none;
    border: 1px solid #DDAA88;
    line-height: 1;
  }

  .revealed {
    background-color: #FFFFFF;
  }

  .word-owned-user {
    background-color: #FFDCDC; /* ì‚¬ìš©ì ì ìœ  ì…€: ì—°í•‘í¬ */
  }

  .word-owned-computer {
    background-color: #CDFFD1; /* ì»´í“¨í„° ì ìœ  ì…€: ì—°ë‘*/
  }

  #currentTurn {
    font-size: 20px;
    margin: 10px;
    color: #A65A5A;
  }

  #game {
    display: grid;
    grid-template-columns: repeat(19, 1fr);
    grid-gap: 2px;
    padding: 3px;
    border: 2px solid #C89A7B;
    background-color: #FFF2EB;
    max-width: 800px;
    margin: 0 auto;
  }

  .hidden {
    display: none;
  }

  /* ëª¨ë°”ì¼ ë°˜ì‘í˜• ìŠ¤íƒ€ì¼ */
  @media (max-width: 768px) {
    h1 {
      font-size: 24px;
      margin-bottom: 8px;
    }

    p {
      font-size: 12px;
      margin: 0 10px 15px;
    }

    .score-display {
      font-size: 20px;
      margin: 15px 0;
    }

    #game {
      grid-template-columns: repeat(19, 1fr);
      width: 100%;
      max-width: 100%;
      margin: 0 auto;
    }

    .cell {
      width: 16px;
      height: 16px;
      font-size: 10px;
    }

    #currentTurn {
      font-size: 18px;
      margin: 8px;
    }

    .game-button {
      font-size: 16px;
      padding: 8px 18px;
      margin: 5px;
    }

    .controls {
      margin-top: 10px;
    }
  }

</style>

</head>

<body>

<h1 id="game-title">WORPUZZMONG</h1>
<p id="game-desc"></p>
<div class="game-container">

  <div id="gameSection">
    <div id="currentTurn"></div>

<div class="score-display">
  <span class="score-computer">ì»´í“¨í„° /COMPUTER: <span id="computerScoreNum">0</span></span>  <span class="score-user">ì‚¬ìš©ì /USER: <span id="userScoreNum">0</span></span>
</div>

<div id="game"></div>

<div class="controls">
  <button id="retryBtn" class="game-button">ë‹¤ì‹œ í•˜ê¸°/ RETRY</button>
  <button onclick="location.href='index.html'" class="game-button">í™ˆìœ¼ë¡œ/ HOME</button>
</div>

  </div>

</div>

<script>

const gridSize = 19;
const gridHeight = 12;
const totalCells = gridSize * gridHeight;

// ğŸ® ê²Œì„ ìƒíƒœ ë³€ìˆ˜ë“¤
let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
let clovers = new Set(), daisies = new Set();
let resultShown = false;
let npcTimeoutId = null;

// ğŸ“¦ DOM ìš”ì†Œ ì—°ê²°
const gameEl = document.getElementById('game');
const retryBtn = document.getElementById('retryBtn');
const gameSection = document.getElementById('gameSection');
const currentTurnEl = document.getElementById('currentTurn');
const userScoreEl = document.getElementById('userScoreNum');
const computerScoreEl = document.getElementById('computerScoreNum');

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    // ê¸´ ë‹¨ì–´ë“¤ì„ í¬í•¨í•œ ê¸°ë³¸ ë‹¨ì–´ë“¤ ì„¤ì •
    words = [
      'GRANDFATHER', 'GRANDMOTHER', 'GRANDPARENT', 'INTERESTING', 
      'SUPERMARKET', 'CONVERSATION', 'INFORMATION', 'DESCRIPTION',
      'UNDERSTANDING', 'INTERNATIONAL', 'ENTERTAINMENT', 'DEVELOPMENT',
      'HELLO', 'WORLD', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'SEARCH'
    ];
    gameSection.classList.remove('hidden');
    init();
    return;
  }

  fetch('wordpools/' + poolFile + '.json')
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || 'ì›Œí¼ì¦ˆëª½ (WORPUZZMONG)';
      const rawText = data.description || 'ë‹¨ì–´ë¥¼ ì°¾ì•„ì„œ ì ìˆ˜ë¥¼ ì–»ëŠ” ê²Œì„ì…ë‹ˆë‹¤.';
      const htmlText = rawText.replace(/\n/g, '<br>');
      document.getElementById('game-desc').innerHTML = htmlText;

      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        words.push(...getRandomSample(data.words[length], count));
      }
      console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
      console.log('ë‹¨ì–´ ëª©ë¡:', words);
      
      // ê²Œì„ ì„¹ì…˜ ë³´ì´ê¸° ë° ì´ˆê¸°í™”
      gameSection.classList.remove('hidden');
      init();
    })
    .catch(err => {
      // ì—ëŸ¬ ë°œìƒ ì‹œ ê¸´ ë‹¨ì–´ë“¤ì„ í¬í•¨í•œ ê¸°ë³¸ ë‹¨ì–´ë“¤ë¡œ ì§„í–‰
      words = [
        'GRANDFATHER', 'GRANDMOTHER', 'GRANDPARENT', 'INTERESTING', 
        'SUPERMARKET', 'CONVERSATION', 'INFORMATION', 'DESCRIPTION',
        'UNDERSTANDING', 'INTERNATIONAL', 'ENTERTAINMENT', 'DEVELOPMENT',
        'HELLO', 'WORLD', 'GAME', 'PLAY', 'WORD', 'PUZZLE', 'FIND', 'SEARCH'
      ];
      gameSection.classList.remove('hidden');
      init();
    });
};

// ğŸ”€ ë°°ì—´ì„ ë¬´ì‘ìœ„ë¡œ ì„ëŠ” í•¨ìˆ˜ (Fisherâ€“Yates ì•Œê³ ë¦¬ì¦˜)
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

// ğŸ² ë°°ì—´ì—ì„œ ì›í•˜ëŠ” ê°œìˆ˜ë§Œí¼ ëœë¤ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜
function getRandomSample(arr, count) {
  if (count >= arr.length) return [...arr];
  const shuffled = [...arr];
  shuffle(shuffled);
  return shuffled.slice(0, count);
}

function init() {
  board = Array(totalCells).fill(null);
  revealed = Array(totalCells).fill(false);
  wordMap = {};
  foundWords = new Set();
  foundBy = { user: 0, computer: 0 };
  currentPlayer = 'user';
  usedIndexes = new Set();
  clovers.clear();
  daisies.clear();
  resultShown = false;

  // íƒ€ì´ë¨¸ ì •ë¦¬
  if (npcTimeoutId) {
    clearTimeout(npcTimeoutId);
    npcTimeoutId = null;
  }

  createGrid();
  
  // ê¸´ ë‹¨ì–´ë¶€í„° ë¨¼ì € ë°°ì¹˜í•˜ëŠ” ì „ëµ
  if (placeAllWordsLongFirst()) {
    console.log('ëª¨ë“  ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤ (ê¸´ ë‹¨ì–´ ìš°ì„ )');
  } else {
    console.log('ê¸´ ë‹¨ì–´ ìš°ì„  ë°°ì¹˜ ì‹¤íŒ¨ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
    // ê¸°ë³¸ ë°°ì¹˜ ë¡œì§
    let placedWords = [];
    shuffle(words);
    
    for (let word of words) {
      let placed = false;
      for (let attempt = 0; attempt < 1000; attempt++) {
        if (placeWord(word)) {
          placedWords.push(word);
          placed = true;
          break;
        }
      }
      if (!placed) {
        console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
      }
    }
    console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
  }
  
  // ë°ì´ì§€ 5%, í´ë¡œë²„ 10% ë°°ì¹˜
  const daisyCount = Math.round(totalCells * 0.05);
  const cloverCount = Math.round(totalCells * 0.10);
  
  placeDaisies(daisyCount);
  placeClovers(cloverCount);
  fillEmptyCells();
  updateScore();
  updateTurnDisplay();
  
  checkGameEnd();
}

function createGrid() {
  gameEl.innerHTML = '';
  for (let i = 0; i < totalCells; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.onclick = () => { if (!resultShown) handleClick(i); };
    gameEl.appendChild(cell);
  }
}

function canPlaceWord(word, x, y, dx, dy) {
  // ê²½ê³„ í™•ì¸ ê°œì„ 
  const endX = x + dx * (word.length - 1);
  const endY = y + dy * (word.length - 1);
  
  if (endX < 0 || endY < 0 || endX >= gridSize || endY >= gridHeight) return false;
  
  for (let i = 0; i < word.length; i++) {
    let nx = x + dx * i;
    let ny = y + dy * i;
    let idx = ny * gridSize + nx;
    
    // ì´ë¯¸ ë‹¤ë¥¸ ë¬¸ìê°€ ìˆê³  í˜„ì¬ ë¬¸ìì™€ ë‹¤ë¥´ë©´ ë°°ì¹˜ ë¶ˆê°€
    if (board[idx] && board[idx] !== word[i]) return false;
    
    // ì´ë¯¸ ë‹¤ë¥¸ ë‹¨ì–´ì— ì˜í•´ ì‚¬ìš©ëœ ìœ„ì¹˜ë©´ ë°°ì¹˜ ë¶ˆê°€
    if (usedIndexes.has(idx)) return false;
  }
  return true;
}

function placeWord(word) {
  const directions = [
    { x: 1, y: 0 },   // ê°€ë¡œ (ì˜¤ë¥¸ìª½)
    { x: 0, y: 1 },   // ì„¸ë¡œ (ì•„ë˜)
    { x: 1, y: 1 },   // ëŒ€ê°ì„  (ì˜¤ë¥¸ìª½ ì•„ë˜)
  ];
  
  // ë°©í–¥ì„ ì„ì–´ì„œ ë‹¤ì–‘ì„± í™•ë³´
  const shuffledDirections = directions.sort(() => Math.random() - 0.5);
  
  // ì‹œì‘ ìœ„ì¹˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì‹œë„
  const positions = [];
  for (let y = 0; y < gridHeight; y++) {
    for (let x = 0; x < gridSize; x++) {
      positions.push({x, y});
    }
  }
  shuffle(positions);
 
  for (let dir of shuffledDirections) {
    for (let pos of positions) {
      if (canPlaceWord(word, pos.x, pos.y, dir.x, dir.y)) {
        let positions = [];
        for (let i = 0; i < word.length; i++) {
          let nx = pos.x + dir.x * i;
          let ny = pos.y + dir.y * i;
          let idx = ny * gridSize + nx;
          board[idx] = word[i];
          usedIndexes.add(idx);
          positions.push(idx);
        }
        wordMap[word] = {
          positions: positions,
          direction: [dir.x, dir.y]
        };
        console.log(`ë‹¨ì–´ "${word}" ë°°ì¹˜ ì™„ë£Œ (${pos.x},${pos.y}) ë°©í–¥(${dir.x},${dir.y})`);
        return true;
      }
    }
  }
  return false;
}

function checkDirectionVariety() {
  let directionCount = {
    '1,0': 0,    // ê°€ë¡œ
    '0,1': 0,    // ì„¸ë¡œ
    '1,1': 0     // ëŒ€ê°ì„ 
  };
  
  for (let word in wordMap) {
    const direction = wordMap[word].direction;
    const key = direction[0] + ',' + direction[1];
    if (directionCount.hasOwnProperty(key)) {
      directionCount[key]++;
    }
  }
  
  console.log('ë°©í–¥ë³„ ì‚¬ìš© íšŸìˆ˜:', directionCount);
  return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
}

// ê¸´ ë‹¨ì–´ë¶€í„° ë°°ì¹˜í•˜ëŠ” ìƒˆë¡œìš´ í•¨ìˆ˜
function placeAllWordsLongFirst() {
  let attempts = 0;
  const maxAttempts = 15;
  
  do {
    board = Array(totalCells).fill(null);
    usedIndexes.clear();
    wordMap = {};
    
    // ê¸´ ë‹¨ì–´ë¶€í„° ë°°ì¹˜ (ê¸¸ì´ ìˆœìœ¼ë¡œ ì •ë ¬)
    const sortedWords = [...words].sort((a, b) => b.length - a.length);
    console.log('ë°°ì¹˜ ìˆœì„œ (ê¸¸ì´ë³„):', sortedWords.map(w => `${w}(${w.length})`));
    
    let allPlaced = true;
    for (let word of sortedWords) {
      if (!placeWord(word)) {
        console.log(`ë°°ì¹˜ ì‹¤íŒ¨: ${word} (ê¸¸ì´: ${word.length})`);
        allPlaced = false;
        break;
      }
    }
    
    if (allPlaced && checkDirectionVariety()) {
      console.log(`ì„±ê³µ! ${attempts + 1}ë²ˆì§¸ ì‹œë„ì—ì„œ ëª¨ë“  ë‹¨ì–´ ë°°ì¹˜ ë° 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ë¨`);
      return true;
    }
    
    attempts++;
    console.log(`${attempts}ë²ˆì§¸ ì‹œë„ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„`);
  } while (attempts < maxAttempts);
  
  console.log('ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
  return false;
}

function placeClovers(count) {
  let placed = 0;
  let attempts = 0;
  while (placed < count && attempts < 1000) {
    const idx = Math.floor(Math.random() * totalCells);
    if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
      if (isSafeForSpecial(idx)) {
        clovers.add(idx);
        placed++;
      }
    }
    attempts++;
  }
  console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
}

function placeDaisies(count) {
  let placed = 0;
  let attempts = 0;
  while (placed < count && attempts < 1000) {
    const idx = Math.floor(Math.random() * totalCells);
    if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
      if (isSafeForSpecial(idx)) {
        daisies.add(idx);
        placed++;
      }
    }
    attempts++;
  }
  console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
}

function isSafeForSpecial(idx) {
  const x = idx % gridSize;
  const y = Math.floor(idx / gridSize);
  
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridHeight) {
        const nIdx = ny * gridSize + nx;
        if (clovers.has(nIdx) || daisies.has(nIdx)) {
          return false;
        }
      }
    }
  }
  return true;
}

function fillEmptyCells() {
  const filler = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  shuffle(filler);
  let i = 0;
  for (let j = 0; j < totalCells; j++) {
    if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
      board[j] = filler[i++ % filler.length];
    }
  }
}

function reveal(index) {
  if (revealed[index]) return;
  revealed[index] = true;
  const cell = gameEl.children[index];
  
  if (clovers.has(index)) {
    cell.textContent = 'ğŸ€';
    const directions = [-gridSize, gridSize, -1, 1];
    for (let d of directions) {
      const newIdx = index + d;
      if (newIdx >= 0 && newIdx < totalCells) {
        if (d === -1 || d === 1) {
          if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
            reveal(newIdx);
          }
        } else {
          reveal(newIdx);
        }
      }
    }
  } else if (daisies.has(index)) {
    cell.textContent = 'ğŸŒ¼';
    const x = index % gridSize;
    const y = Math.floor(index / gridSize);
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridHeight) {
          const nIdx = ny * gridSize + nx;
          if (!revealed[nIdx]) reveal(nIdx);
        }
      }
    }
  } else {
    cell.textContent = board[index];
  }
  cell.classList.add('revealed');
}

function updateScore() {
  userScoreEl.textContent = foundBy.user;
  computerScoreEl.textContent = foundBy.computer;
}

function updateTurnDisplay() {
  if (resultShown) return;
  const name = currentPlayer === 'user' ? 'USER' : 'COMPUTER';
  currentTurnEl.textContent = `It is ${name}'s turn.`;
}

function switchTurn(extra) {
  if (!extra) {
    currentPlayer = currentPlayer === 'user' ? 'computer' : 'user';
  }
  updateTurnDisplay();
  
  // ğŸ¤– ì»´í“¨í„° í„´ì´ë©´ ìë™ í”Œë ˆì´
  if (currentPlayer === 'computer' && !resultShown) {
    npcTimeoutId = setTimeout(() => {
      computerMove();
    }, 1000); // 1ì´ˆ í›„ ì»´í“¨í„° í–‰ë™
  }
}

// ğŸ¤– ì»´í“¨í„° ëœë¤ í´ë¦­ í•¨ìˆ˜
function computerMove() {
  if (resultShown) return;
  
  // ì•„ì§ ì—´ë¦¬ì§€ ì•Šì€ ì…€ë“¤ ì°¾ê¸°
  const availableCells = [];
  for (let i = 0; i < totalCells; i++) {
    if (!revealed[i]) {
      availableCells.push(i);
    }
  }
  
  if (availableCells.length === 0) return;
  
  // ëœë¤ìœ¼ë¡œ ì…€ ì„ íƒ
  const randomIndex = Math.floor(Math.random() * availableCells.length);
  const selectedCell = availableCells[randomIndex];
  
  console.log('ì»´í“¨í„°ê°€ ì„ íƒí•œ ì…€:', selectedCell);
  handleClickInternal(selectedCell, 'computer'); // ì»´í“¨í„° í´ë¦­ì„ì„ ëª…ì‹œ
}

function handleClick(index) {
  // ì‚¬ìš©ì í´ë¦­ì€ ì‚¬ìš©ì í„´ì¼ ë•Œë§Œ í—ˆìš©
  if (currentPlayer !== 'user' || revealed[index] || resultShown) return;
  
  handleClickInternal(index, 'user');
}

function handleClickInternal(index, player) {
  if (revealed[index] || resultShown) return;

  // í˜„ì¬ í”Œë ˆì´ì–´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •
  currentPlayer = player;
  
  const extra = clovers.has(index) || daisies.has(index);
  reveal(index);
  checkWords();
  checkGameEnd();

  if (!resultShown) {
    switchTurn(extra);
  }
}

function checkWords() {
  for (let word of Object.keys(wordMap)) {
    if (foundWords.has(word)) continue;
    const pos = wordMap[word].positions;
    if (pos.every(i => revealed[i])) {
      foundWords.add(word);
      foundBy[currentPlayer]++;
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add(
          currentPlayer === 'user' ? 'word-owned-user' : 'word-owned-computer'
        );
      });
      updateScore();
      console.log(`${currentPlayer}ê°€ ë‹¨ì–´ "${word}" ë°œê²¬!`);
    }
  }
}

function checkGameEnd() {
  const totalWords = Object.keys(wordMap).length;
  if (foundWords.size >= totalWords && totalWords > 0) {
    resultShown = true;
    
    // íƒ€ì´ë¨¸ ì •ë¦¬
    if (npcTimeoutId) {
      clearTimeout(npcTimeoutId);
      npcTimeoutId = null;
    }
    
    const userWords = foundBy.user;
    const computerWords = foundBy.computer;
    let winner = '';
    
    if (userWords > computerWords) {
      winner = 'USER WINS!';
    } else if (computerWords > userWords) {
      winner = 'COMPUTER WINS!';
    } else {
      winner = 'DRAW!';
    }
    
    currentTurnEl.textContent = `Game Over! ${winner}`;
    
    setTimeout(() => {
      alert(`Game Over!\n\nUSER: ${userWords} words\nCOMPUTER: ${computerWords} words\n\n${winner}`);
    }, 500);
  }
}

// ğŸ”„ ë‹¤ì‹œí•˜ê¸° ë²„íŠ¼
retryBtn.onclick = () => {
  init();
};

</script>

</body>
</html>
